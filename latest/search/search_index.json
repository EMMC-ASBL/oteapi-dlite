{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#oteapi-dlite-plugin","title":"OTEAPI DLite Plugin","text":"<p>All strategies implemented in this plugin (except for <code>create_collection</code>) assumes that you have the UUID of a DLite collection with the key <code>collection_id</code> in the <code>session</code>:</p> <pre><code>collection_id = session[\"collection_id\"]\ncoll = dlite.get_collection(collection_id)\n</code></pre> <p>A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case.</p> <p>In order to make it easy retrieve the collection id when executing a pipeline, the <code>get()</code> method of all filters in this plugin should return the <code>collection_id</code>.</p> <p>Further reading:</p> <ul> <li>OTE-API Core Documentation</li> <li>OTE-API Services Documentation</li> <li>DLite</li> </ul> <p>A list and documentation for all the strategies in this plugin can be found here.</p>"},{"location":"#license-and-copyright","title":"License and copyright","text":"<p>The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins.</p> <p>OTEAPI DLite Plugin has been supported by the following projects:</p> <ul> <li> <p>OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136.</p> </li> <li> <p>VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903.</p> </li> <li> <p>OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>This file will hold an auto-generated changelog for you project.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"all_strategies/","title":"OTEAPI DLite Plugin Strategies","text":"<p>This page provides documentation for the <code>oteapi_dlite.strategies</code> submodule, where all the OTEAPI DLite Plugin strategies are located.</p> <p>These strategies will be available when setting up a server in an environment with oteapi-dlite installed.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert","title":"<code>convert</code>","text":"<p>Generic function strategy that converts zero or more input instances to zero or more new output instances.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertConfig","title":"<code>DLiteConvertConfig</code>","text":"<p>               Bases: <code>FunctionConfig</code></p> <p>DLite convert strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertConfig(FunctionConfig):\n    \"\"\"DLite convert strategy resource config.\"\"\"\n\n    configuration: Annotated[\n        DLiteConvertStrategyConfig,\n        Field(description=\"DLite convert strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertConfig.configuration","title":"<code>configuration: Annotated[DLiteConvertStrategyConfig, Field(description='DLite convert strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig","title":"<code>DLiteConvertInputConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for input instance to generic DLite converter.</p> <p>At least one of <code>label</code> or <code>datamodel</code> should be given.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertInputConfig(AttrDict):\n    \"\"\"Configuration for input instance to generic DLite converter.\n\n    At least one of `label` or `datamodel` should be given.\n    \"\"\"\n\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=\"Label of the instance.\",\n        ),\n    ] = None\n    datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=\"URI of data model.\",\n        ),\n    ] = None\n    property_mappings: Annotated[\n        bool,\n        Field(\n            description=\"Whether to infer instance from property mappings.\",\n        ),\n    ] = False\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig.datamodel","title":"<code>datamodel: Annotated[Optional[str], Field(description='URI of data model.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Label of the instance.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig.property_mappings","title":"<code>property_mappings: Annotated[bool, Field(description='Whether to infer instance from property mappings.')] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertOutputConfig","title":"<code>DLiteConvertOutputConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for output instance to generic DLite converter.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertOutputConfig(AttrDict):\n    \"\"\"Configuration for output instance to generic DLite converter.\"\"\"\n\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=\"Label to use when storing the instance.\",\n        ),\n    ] = None\n    datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=\"URI of data model.  Used for documentation.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertOutputConfig.datamodel","title":"<code>datamodel: Annotated[Optional[str], Field(description='URI of data model.  Used for documentation.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertOutputConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Label to use when storing the instance.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategy","title":"<code>DLiteConvertStrategy</code>","text":"<p>Generic DLite convert strategy for converting zero or more input instances to zero or more output instances.</p> <p>Registers strategies:</p> <ul> <li><code>(\"functionType\", \"application/vnd.dlite-convert\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>@dataclass\nclass DLiteConvertStrategy:\n    \"\"\"Generic DLite convert strategy for converting zero or more input\n    instances to zero or more output instances.\n\n    **Registers strategies**:\n\n    - `(\"functionType\", \"application/vnd.dlite-convert\")`\n\n    \"\"\"\n\n    convert_config: DLiteConvertConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.convert_config.configuration\n\n        module = importlib.import_module(config.module_name, config.package)\n        function = getattr(module, config.function_name)\n\n        coll = get_collection(session)\n\n        instances = []\n        for i, input_config in enumerate(config.inputs):\n            input_config = config.inputs[i]\n            if input_config.label:\n                instances.append(\n                    coll.get(input_config.label, input_config.datamodel)\n                )\n            elif input_config.datamodel:\n                inst = coll.get_instances(\n                    metaid=input_config.datamodel,\n                    property_mappings=input_config.property_mappings,\n                    # More to do: add more arguments...\n                )\n            else:\n                raise ValueError(\n                    \"either `label` or `datamodel` must be specified in \"\n                    f\"inputs[{i}]\"\n                )\n\n        outputs = function(*instances)\n        if isinstance(outputs, dlite.Instance):\n            outputs = [outputs]\n\n        for inst, output_config in zip(outputs, config.outputs):\n            coll.add(output_config.label, inst)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategy.convert_config","title":"<code>convert_config: DLiteConvertConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.convert_config.configuration\n\n    module = importlib.import_module(config.module_name, config.package)\n    function = getattr(module, config.function_name)\n\n    coll = get_collection(session)\n\n    instances = []\n    for i, input_config in enumerate(config.inputs):\n        input_config = config.inputs[i]\n        if input_config.label:\n            instances.append(\n                coll.get(input_config.label, input_config.datamodel)\n            )\n        elif input_config.datamodel:\n            inst = coll.get_instances(\n                metaid=input_config.datamodel,\n                property_mappings=input_config.property_mappings,\n                # More to do: add more arguments...\n            )\n        else:\n            raise ValueError(\n                \"either `label` or `datamodel` must be specified in \"\n                f\"inputs[{i}]\"\n            )\n\n    outputs = function(*instances)\n    if isinstance(outputs, dlite.Instance):\n        outputs = [outputs]\n\n    for inst, output_config in zip(outputs, config.outputs):\n        coll.add(output_config.label, inst)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig","title":"<code>DLiteConvertStrategyConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for generic DLite converter.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertStrategyConfig(AttrDict):\n    \"\"\"Configuration for generic DLite converter.\"\"\"\n\n    function_name: Annotated[\n        str,\n        Field(\n            description=\"Name of convert function.  It will be pased the input \"\n            \"instances as arguments and should return a sequence of output \"\n            \"instances.\",\n        ),\n    ]\n    module_name: Annotated[\n        str,\n        Field(\n            description=(\n                \"Name of Python module containing the convertion function.\"\n            ),\n        ),\n    ]\n    package: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Used when performing a relative import of the converter \"\n                \"function.  It specifies the package to use as the anchor \"\n                \"point from which to resolve the relative import to an absolute\"\n                \" import.\"\n            ),\n        ),\n    ] = None\n    pypi_package: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Package name on PyPI.  This field is currently only \"\n                \"informative, but might be used in the future for automatic \"\n                \"package installation.\"\n            ),\n        ),\n    ] = None\n    inputs: Annotated[\n        Sequence[DLiteConvertInputConfig],\n        Field(\n            description=\"Input instances.\",\n        ),\n    ] = []\n    outputs: Annotated[\n        Sequence[DLiteConvertOutputConfig],\n        Field(\n            description=\"Output instances.\",\n        ),\n    ] = []\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.function_name","title":"<code>function_name: Annotated[str, Field(description='Name of convert function.  It will be pased the input instances as arguments and should return a sequence of output instances.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.inputs","title":"<code>inputs: Annotated[Sequence[DLiteConvertInputConfig], Field(description='Input instances.')] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.module_name","title":"<code>module_name: Annotated[str, Field(description='Name of Python module containing the convertion function.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.outputs","title":"<code>outputs: Annotated[Sequence[DLiteConvertOutputConfig], Field(description='Output instances.')] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.package","title":"<code>package: Annotated[Optional[str], Field(description='Used when performing a relative import of the converter function.  It specifies the package to use as the anchor point from which to resolve the relative import to an absolute import.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.pypi_package","title":"<code>pypi_package: Annotated[Optional[str], Field(description='Package name on PyPI.  This field is currently only informative, but might be used in the future for automatic package installation.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.filter","title":"<code>filter</code>","text":"<p>Filter that removes all but specified instances in the collection.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteFilterConfig","title":"<code>DLiteFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>DLite generate strategy config.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>class DLiteFilterConfig(FilterConfig):\n    \"\"\"DLite generate strategy config.\"\"\"\n\n    configuration: Annotated[\n        DLiteQueryConfig,\n        Field(description=\"DLite filter strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteFilterConfig.configuration","title":"<code>configuration: Annotated[DLiteQueryConfig, Field(description='DLite filter strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteFilterStrategy","title":"<code>DLiteFilterStrategy</code>","text":"<p>Filter that removes all but specified instances in the collection.</p> <p>The <code>query</code> configuration should be a regular expression matching labels to keep in the collection.  All other labels will be removed.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"dlite/filter\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>@dataclass\nclass DLiteFilterStrategy:\n    \"\"\"Filter that removes all but specified instances in the collection.\n\n    The `query` configuration should be a regular expression matching labels\n    to keep in the collection.  All other labels will be removed.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"dlite/filter\")`\n\n    \"\"\"\n\n    filter_config: DLiteFilterConfig\n\n    def initialize(\n        self,\n        session: \"Optional[dict[str, Any]]\" = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\"\"\"\n        # pylint: disable=too-many-branches\n        config = self.filter_config.configuration\n\n        # Alias for query configuration\n        keep_label = (\n            config.keep_label if config.keep_label else self.filter_config.query\n        )\n\n        instdict = {}  # Map instance labels to [uuid, metaURI]\n        coll = get_collection(session)\n        for s, _, o in coll.get_relations(p=\"_has-uuid\"):\n            instdict[s] = [o]\n        for s, _, o in coll.get_relations(p=\"_has-meta\"):\n            instdict[s].append(o)\n\n        removal = set()  # Labels marked for removal\n\n        # 1: remove_label, remove_datamodel\n        if config.remove_label or config.remove_datamodel:\n            for label, (_, metauri) in instdict.items():\n                if config.remove_label and re.match(config.remove_label, label):\n                    removal.add(label)\n\n                if config.remove_datamodel and re.match(\n                    config.remove_datamodel, metauri\n                ):\n                    removal.add(label)\n        else:\n            removal.update(instdict.keys())\n\n        # 2: keep_label, keep_datamodel\n        for label in set(removal):\n            if keep_label and re.match(keep_label, label):\n                removal.remove(label)\n\n            _, metauri = instdict[label]\n            if config.keep_datamodel and re.match(\n                config.keep_datamodel, metauri\n            ):\n                removal.remove(label)\n\n        # 3: keep_referred\n        if config.keep_referred:\n            labels = {uuid: label for label, (uuid, _) in instdict.items()}\n            kept = set(instdict.keys()).difference(removal)\n            for label in kept:\n                removal.difference_update(\n                    labels[inst.uuid]\n                    for inst in get_referred_instances(coll.get(label))\n                    if inst.uuid in labels\n                )\n\n        # 4: remove from collection\n        for label in removal:\n            coll.remove(label)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteFilterStrategy.filter_config","title":"<code>filter_config: DLiteFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteFilterStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>def get(\n    self, session: \"Optional[dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\"\"\"\n    # pylint: disable=too-many-branches\n    config = self.filter_config.configuration\n\n    # Alias for query configuration\n    keep_label = (\n        config.keep_label if config.keep_label else self.filter_config.query\n    )\n\n    instdict = {}  # Map instance labels to [uuid, metaURI]\n    coll = get_collection(session)\n    for s, _, o in coll.get_relations(p=\"_has-uuid\"):\n        instdict[s] = [o]\n    for s, _, o in coll.get_relations(p=\"_has-meta\"):\n        instdict[s].append(o)\n\n    removal = set()  # Labels marked for removal\n\n    # 1: remove_label, remove_datamodel\n    if config.remove_label or config.remove_datamodel:\n        for label, (_, metauri) in instdict.items():\n            if config.remove_label and re.match(config.remove_label, label):\n                removal.add(label)\n\n            if config.remove_datamodel and re.match(\n                config.remove_datamodel, metauri\n            ):\n                removal.add(label)\n    else:\n        removal.update(instdict.keys())\n\n    # 2: keep_label, keep_datamodel\n    for label in set(removal):\n        if keep_label and re.match(keep_label, label):\n            removal.remove(label)\n\n        _, metauri = instdict[label]\n        if config.keep_datamodel and re.match(\n            config.keep_datamodel, metauri\n        ):\n            removal.remove(label)\n\n    # 3: keep_referred\n    if config.keep_referred:\n        labels = {uuid: label for label, (uuid, _) in instdict.items()}\n        kept = set(instdict.keys()).difference(removal)\n        for label in kept:\n            removal.difference_update(\n                labels[inst.uuid]\n                for inst in get_referred_instances(coll.get(label))\n                if inst.uuid in labels\n            )\n\n    # 4: remove from collection\n    for label in removal:\n        coll.remove(label)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteFilterStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[dict[str, Any]]\" = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteQueryConfig","title":"<code>DLiteQueryConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for the DLite filter strategy.</p> <p>First the <code>remove_label</code> and <code>remove_datamodel</code> configurations are used to mark matching instances for removal.  If neither <code>remove_label</code> or <code>remove_datamodel</code> are given, all instances are marked for removal.</p> <p>Then instances matching <code>keep_label</code> and <code>keep_datamodel</code> are unmarked for removal.</p> <p>If <code>keep_referred</code> is true, any instance that is referred to by an instance not marked for removal is also unmarked for removal.</p> <p>Finally, the instances that are still marked for removal are removed from the collection.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>class DLiteQueryConfig(AttrDict):\n    \"\"\"Configuration for the DLite filter strategy.\n\n    First the `remove_label` and `remove_datamodel` configurations are\n    used to mark matching instances for removal.  If neither\n    `remove_label` or `remove_datamodel` are given, all instances are\n    marked for removal.\n\n    Then instances matching `keep_label` and `keep_datamodel` are unmarked\n    for removal.\n\n    If `keep_referred` is true, any instance that is referred to by\n    an instance not marked for removal is also unmarked for removal.\n\n    Finally, the instances that are still marked for removal are removed\n    from the collection.\n    \"\"\"\n\n    remove_label: Annotated[\n        Optional[str],\n        Field(description=\"Regular expression matching labels to remove.\"),\n    ] = None\n    remove_datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=\"Regular expression matching datamodel URIs to remove.\",\n        ),\n    ] = None\n    keep_label: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Regular expression matching labels to keep. This \"\n                \"configuration overrides `remove_label` and \"\n                \"`remove_datamodel`. Alias for the FilterStrategy `query` \"\n                \"configuration, that is inherited from the oteapi-core Filter \"\n                \"data model.\"\n            ),\n        ),\n    ] = None\n    keep_datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Regular expression matching datamodel URIs to keep in \"\n                \"collection. This configuration overrides `remove_label` and \"\n                \"`remove_datamodel`.\"\n            ),\n        ),\n    ] = None\n    keep_referred: Annotated[\n        bool,\n        Field(\n            description=(\n                \"Whether to keep all instances in the collection that are \"\n                \"directly or indirectly referred to (via ref-types or \"\n                \"collections) by kept instances.\"\n            ),\n        ),\n    ] = True\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteQueryConfig.keep_datamodel","title":"<code>keep_datamodel: Annotated[Optional[str], Field(description='Regular expression matching datamodel URIs to keep in collection. This configuration overrides `remove_label` and `remove_datamodel`.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteQueryConfig.keep_label","title":"<code>keep_label: Annotated[Optional[str], Field(description='Regular expression matching labels to keep. This configuration overrides `remove_label` and `remove_datamodel`. Alias for the FilterStrategy `query` configuration, that is inherited from the oteapi-core Filter data model.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteQueryConfig.keep_referred","title":"<code>keep_referred: Annotated[bool, Field(description='Whether to keep all instances in the collection that are directly or indirectly referred to (via ref-types or collections) by kept instances.')] = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteQueryConfig.remove_datamodel","title":"<code>remove_datamodel: Annotated[Optional[str], Field(description='Regular expression matching datamodel URIs to remove.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.filter.DLiteQueryConfig.remove_label","title":"<code>remove_label: Annotated[Optional[str], Field(description='Regular expression matching labels to remove.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate","title":"<code>generate</code>","text":"<p>Generic generate strategy using DLite storage plugin.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteGenerateConfig","title":"<code>DLiteGenerateConfig</code>","text":"<p>               Bases: <code>FunctionConfig</code></p> <p>DLite generate strategy config.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>class DLiteGenerateConfig(FunctionConfig):\n    \"\"\"DLite generate strategy config.\"\"\"\n\n    configuration: Annotated[\n        DLiteStorageConfig,\n        Field(description=\"DLite generate strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteGenerateConfig.configuration","title":"<code>configuration: Annotated[DLiteStorageConfig, Field(description='DLite generate strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy","title":"<code>DLiteGenerateStrategy</code>","text":"<p>Generic DLite generate strategy utilising DLite storage plugins.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.dlite-generate\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>@dataclass\nclass DLiteGenerateStrategy:\n    \"\"\"Generic DLite generate strategy utilising DLite storage plugins.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.dlite-generate\")`\n\n    \"\"\"\n\n    generate_config: DLiteGenerateConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.generate_config.configuration\n        cacheconfig = config.datacache_config\n\n        driver = (\n            config.driver\n            if config.driver\n            else get_driver(\n                mediaType=config.mediaType,\n            )\n        )\n\n        coll = get_collection(session, config.collection_id)\n\n        if config.label:\n            inst = coll[config.label]\n        elif config.datamodel:\n            instances = coll.get_instances(\n                metaid=config.datamodel,\n                property_mappings=True,\n                allow_incomplete=config.allow_incomplete,\n            )\n            inst = next(instances)\n        elif config.store_collection:\n            if config.store_collection_id:\n                inst = coll.copy(newid=config.store_collection_id)\n            else:\n                inst = coll\n        else:  # fail if there are more instances\n            raise ValueError(\n                \"One of `label` or `datamodel` configurations should be given.\"\n            )\n\n        # Save instance\n        if config.location:\n            inst.save(driver, config.location, config.options)\n        else:  # missing test\n            if cacheconfig and cacheconfig.accessKey:\n                key = cacheconfig.accessKey\n            else:  # missing test\n                key = \"generate_data\"\n            cache = DataCache()\n            with tempfile.TemporaryDirectory() as tmpdir:\n                inst.save(driver, \"{tmpdir}/data\", config.options)\n                with open(f\"{tmpdir}/data\", \"rb\") as f:\n                    cache.add(f.read(), key=key)\n\n        # __TODO__\n        # Can we safely assume that all strategies in a pipeline will be\n        # executed in the same Python interpreter?  If not, we should write\n        # the collection to a storage, such that it can be shared with the\n        # other strategies.\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.generate_config","title":"<code>generate_config: DLiteGenerateConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.generate_config.configuration\n    cacheconfig = config.datacache_config\n\n    driver = (\n        config.driver\n        if config.driver\n        else get_driver(\n            mediaType=config.mediaType,\n        )\n    )\n\n    coll = get_collection(session, config.collection_id)\n\n    if config.label:\n        inst = coll[config.label]\n    elif config.datamodel:\n        instances = coll.get_instances(\n            metaid=config.datamodel,\n            property_mappings=True,\n            allow_incomplete=config.allow_incomplete,\n        )\n        inst = next(instances)\n    elif config.store_collection:\n        if config.store_collection_id:\n            inst = coll.copy(newid=config.store_collection_id)\n        else:\n            inst = coll\n    else:  # fail if there are more instances\n        raise ValueError(\n            \"One of `label` or `datamodel` configurations should be given.\"\n        )\n\n    # Save instance\n    if config.location:\n        inst.save(driver, config.location, config.options)\n    else:  # missing test\n        if cacheconfig and cacheconfig.accessKey:\n            key = cacheconfig.accessKey\n        else:  # missing test\n            key = \"generate_data\"\n        cache = DataCache()\n        with tempfile.TemporaryDirectory() as tmpdir:\n            inst.save(driver, \"{tmpdir}/data\", config.options)\n            with open(f\"{tmpdir}/data\", \"rb\") as f:\n                cache.add(f.read(), key=key)\n\n    # __TODO__\n    # Can we safely assume that all strategies in a pipeline will be\n    # executed in the same Python interpreter?  If not, we should write\n    # the collection to a storage, such that it can be shared with the\n    # other strategies.\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig","title":"<code>DLiteStorageConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for a generic DLite storage filter.</p> <p>The DLite storage driver to can be specified using either the <code>driver</code> or <code>mediaType</code> field.</p> <p>Where the output should be written, is specified using either the <code>location</code> or <code>datacache_config.accessKey</code> field.</p> <p>Either <code>label</code> or <code>datamodel</code> should be provided.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>class DLiteStorageConfig(AttrDict):\n    \"\"\"Configuration for a generic DLite storage filter.\n\n    The DLite storage driver to can be specified using either the `driver`\n    or `mediaType` field.\n\n    Where the output should be written, is specified using either the\n    `location` or `datacache_config.accessKey` field.\n\n    Either `label` or `datamodel` should be provided.\n    \"\"\"\n\n    driver: Annotated[\n        Optional[str],\n        Field(\n            description='Name of DLite driver (ex: \"json\").',\n        ),\n    ] = None\n    mediaType: Annotated[\n        Optional[str],\n        Field(\n            description='Media type for DLite driver (ex: \"application/json\").',\n        ),\n    ] = None\n    options: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Comma-separated list of options passed to the DLite \"\n                \"storage plugin.\"\n            ),\n        ),\n    ] = None\n    location: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Location of storage to write to.  If unset to store in data \"\n                \"cache using the key provided with \"\n                \"`datacache_config.accessKey` (defaults to 'generate_data').\"\n            ),\n        ),\n    ] = None\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Label of DLite instance in the collection to serialise.\"\n            ),\n        ),\n    ] = None\n    datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"URI to the datamodel of the new instance.  Needed when \"\n                \"generating the instance from mappings.  Cannot be combined \"\n                \"with `label`\"\n            ),\n        ),\n    ] = None\n    store_collection: Annotated[\n        bool,\n        Field(\n            description=\"Whether to store the entire collection in the session \"\n            \"instead of a single instance.  Cannot be combined with `label` or \"\n            \"`datamodel`.\",\n        ),\n    ] = False\n    store_collection_id: Annotated[\n        Optional[str],\n        Field(\n            description=\"Used together with `store_collection` If given, store \"\n            \"a copy of the collection with this id.\",\n        ),\n    ] = None\n    allow_incomplete: Annotated[\n        Optional[bool],\n        Field(\n            description=\"Whether to allow incomplete property mappings.\",\n        ),\n    ] = False\n    collection_id: Annotated[\n        Optional[str],\n        Field(\n            description=(\"ID of the collection to use.\"),\n        ),\n    ] = None\n    datacache_config: Annotated[\n        Optional[DataCacheConfig],\n        Field(\n            description=\"Configuration options for the local data cache.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.allow_incomplete","title":"<code>allow_incomplete: Annotated[Optional[bool], Field(description='Whether to allow incomplete property mappings.')] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.collection_id","title":"<code>collection_id: Annotated[Optional[str], Field(description='ID of the collection to use.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.datacache_config","title":"<code>datacache_config: Annotated[Optional[DataCacheConfig], Field(description='Configuration options for the local data cache.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.datamodel","title":"<code>datamodel: Annotated[Optional[str], Field(description='URI to the datamodel of the new instance.  Needed when generating the instance from mappings.  Cannot be combined with `label`')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.driver","title":"<code>driver: Annotated[Optional[str], Field(description='Name of DLite driver (ex: \"json\").')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Label of DLite instance in the collection to serialise.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.location","title":"<code>location: Annotated[Optional[str], Field(description=\"Location of storage to write to.  If unset to store in data cache using the key provided with `datacache_config.accessKey` (defaults to 'generate_data').\")] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.mediaType","title":"<code>mediaType: Annotated[Optional[str], Field(description='Media type for DLite driver (ex: \"application/json\").')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.options","title":"<code>options: Annotated[Optional[str], Field(description='Comma-separated list of options passed to the DLite storage plugin.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.store_collection","title":"<code>store_collection: Annotated[bool, Field(description='Whether to store the entire collection in the session instead of a single instance.  Cannot be combined with `label` or `datamodel`.')] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.generate.DLiteStorageConfig.store_collection_id","title":"<code>store_collection_id: Annotated[Optional[str], Field(description='Used together with `store_collection` If given, store a copy of the collection with this id.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.mapping","title":"<code>mapping</code>","text":"<p>Mapping filter strategy.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingConfig","title":"<code>DLiteMappingConfig</code>","text":"<p>               Bases: <code>MappingConfig</code></p> <p>DLite mapping strategy config.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>class DLiteMappingConfig(MappingConfig):\n    \"\"\"DLite mapping strategy config.\"\"\"\n\n    configuration: Annotated[\n        DLiteMappingStrategyConfig,\n        Field(\n            description=\"DLite mapping strategy-specific configuration.\",\n        ),\n    ] = DLiteMappingStrategyConfig()\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingConfig.configuration","title":"<code>configuration: Annotated[DLiteMappingStrategyConfig, Field(description='DLite mapping strategy-specific configuration.')] = DLiteMappingStrategyConfig()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy","title":"<code>DLiteMappingStrategy</code>","text":"<p>Strategy for a mapping.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mappingType\", \"mappings\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>@dataclass\nclass DLiteMappingStrategy:\n    \"\"\"Strategy for a mapping.\n\n    **Registers strategies**:\n\n    - `(\"mappingType\", \"mappings\")`\n\n    \"\"\"\n\n    mapping_config: DLiteMappingConfig\n\n    def initialize(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize strategy.\"\"\"\n        coll = get_collection(session)\n        ts = Triplestore(backend=\"collection\", collection=coll)\n\n        if self.mapping_config.prefixes:\n            for prefix, iri in self.mapping_config.prefixes.items():\n                ts.bind(prefix, iri)\n\n        if self.mapping_config.triples:\n            ts.add_triples(\n                [\n                    [\n                        ts.expand_iri(t) if isinstance(t, str) else t\n                        for t in triple\n                    ]\n                    for triple in self.mapping_config.triples  # pylint: disable=not-an-iterable\n                ]\n            )\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute strategy and return a dictionary.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.mapping_config","title":"<code>mapping_config: DLiteMappingConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute strategy and return a dictionary.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>def initialize(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize strategy.\"\"\"\n    coll = get_collection(session)\n    ts = Triplestore(backend=\"collection\", collection=coll)\n\n    if self.mapping_config.prefixes:\n        for prefix, iri in self.mapping_config.prefixes.items():\n            ts.bind(prefix, iri)\n\n    if self.mapping_config.triples:\n        ts.add_triples(\n            [\n                [\n                    ts.expand_iri(t) if isinstance(t, str) else t\n                    for t in triple\n                ]\n                for triple in self.mapping_config.triples  # pylint: disable=not-an-iterable\n            ]\n        )\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingStrategyConfig","title":"<code>DLiteMappingStrategyConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for a DLite mapping filter.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>class DLiteMappingStrategyConfig(AttrDict):\n    \"\"\"Configuration for a DLite mapping filter.\"\"\"\n\n    datamodel: Annotated[\n        Optional[AnyUrl],\n        Field(\n            description=\"URI of the datamodel that is mapped.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.mapping.DLiteMappingStrategyConfig.datamodel","title":"<code>datamodel: Annotated[Optional[AnyUrl], Field(description='URI of the datamodel that is mapped.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse","title":"<code>parse</code>","text":"<p>Generic parse strategy using DLite storage plugin.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseConfig","title":"<code>DLiteParseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for generic DLite parser.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>class DLiteParseConfig(AttrDict):\n    \"\"\"Configuration for generic DLite parser.\"\"\"\n\n    driver: Annotated[\n        Optional[str],\n        Field(\n            description='Name of DLite driver (ex: \"json\").',\n        ),\n    ] = None\n    location: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Explicit location of storage.  Normally data is read from the \"\n                \"data cache using `datacache_config.accessKey` (default: \"\n                \"'key').\"\n            ),\n        ),\n    ] = None\n    options: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Comma-separated list of options passed to the DLite storage \"\n                \"plugin.\"\n            ),\n        ),\n    ] = None\n    id: Annotated[\n        Optional[str],\n        Field(\n            description=\"If given, the id of the instance in the storage.\",\n        ),\n    ] = None\n    label: Annotated[\n        str,\n        Field(\n            description=\"Label of the new DLite instance in the collection.\",\n        ),\n    ]\n    datacache_config: Annotated[\n        Optional[DataCacheConfig],\n        Field(\n            description=\"Configuration options for the local data cache.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseConfig.datacache_config","title":"<code>datacache_config: Annotated[Optional[DataCacheConfig], Field(description='Configuration options for the local data cache.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseConfig.driver","title":"<code>driver: Annotated[Optional[str], Field(description='Name of DLite driver (ex: \"json\").')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseConfig.id","title":"<code>id: Annotated[Optional[str], Field(description='If given, the id of the instance in the storage.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseConfig.label","title":"<code>label: Annotated[str, Field(description='Label of the new DLite instance in the collection.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseConfig.location","title":"<code>location: Annotated[Optional[str], Field(description=\"Explicit location of storage.  Normally data is read from the data cache using `datacache_config.accessKey` (default: 'key').\")] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseConfig.options","title":"<code>options: Annotated[Optional[str], Field(description='Comma-separated list of options passed to the DLite storage plugin.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseResourceConfig","title":"<code>DLiteParseResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>DLite parse strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>class DLiteParseResourceConfig(ResourceConfig):\n    \"\"\"DLite parse strategy resource config.\"\"\"\n\n    configuration: Annotated[\n        DLiteParseConfig,\n        Field(description=\"DLite parse strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseResourceConfig.configuration","title":"<code>configuration: Annotated[DLiteParseConfig, Field(description='DLite parse strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseStrategy","title":"<code>DLiteParseStrategy</code>","text":"<p>Generic DLite parse strategy utilising DLite storage plugins.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.dlite-parse\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>@dataclass\nclass DLiteParseStrategy:\n    \"\"\"Generic DLite parse strategy utilising DLite storage plugins.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.dlite-parse\")`\n\n    \"\"\"\n\n    parse_config: DLiteParseResourceConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.parse_config.configuration\n        cacheconfig = config.datacache_config\n\n        driver = (\n            config.driver\n            if config.driver\n            else get_driver(\n                mediaType=self.parse_config.mediaType,\n            )\n        )\n\n        # Create instance\n        if config.location:\n            inst = dlite.Instance.from_location(\n                driver=driver,\n                location=config.location,\n                options=config.options,\n                id=config.id,\n            )\n        else:\n            if cacheconfig and cacheconfig.accessKey:\n                key = cacheconfig.accessKey\n            elif session and \"key\" in session:\n                key = session[\"key\"]\n            else:\n                raise ValueError(\n                    \"either `location` or `datacache_config.accessKey` must be \"\n                    \"provided\"\n                )\n\n            # See if we can extract file suffix from downloadUrl\n            if self.parse_config.downloadUrl:\n                suffix = Path(str(self.parse_config.downloadUrl)).suffix\n            else:\n                suffix = None\n\n            cache = DataCache()\n            with cache.getfile(key, suffix=suffix) as location:\n                inst = dlite.Instance.from_location(\n                    driver=driver,\n                    location=str(location),\n                    options=config.options,\n                    id=config.id,\n                )\n\n        # Insert inst into collection\n        coll = get_collection(session)\n        coll.add(config.label, inst)\n\n        # __TODO__\n        # See\n        # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185\n        # and following comments.\n        #\n        # Since we cannot safely assume that all strategies in a\n        # pipeline will be executed in the same Python interpreter,\n        # the collection should be written to a storage, such that it\n        # can be shared with the other strategies.\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseStrategy.parse_config","title":"<code>parse_config: DLiteParseResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.parse_config.configuration\n    cacheconfig = config.datacache_config\n\n    driver = (\n        config.driver\n        if config.driver\n        else get_driver(\n            mediaType=self.parse_config.mediaType,\n        )\n    )\n\n    # Create instance\n    if config.location:\n        inst = dlite.Instance.from_location(\n            driver=driver,\n            location=config.location,\n            options=config.options,\n            id=config.id,\n        )\n    else:\n        if cacheconfig and cacheconfig.accessKey:\n            key = cacheconfig.accessKey\n        elif session and \"key\" in session:\n            key = session[\"key\"]\n        else:\n            raise ValueError(\n                \"either `location` or `datacache_config.accessKey` must be \"\n                \"provided\"\n            )\n\n        # See if we can extract file suffix from downloadUrl\n        if self.parse_config.downloadUrl:\n            suffix = Path(str(self.parse_config.downloadUrl)).suffix\n        else:\n            suffix = None\n\n        cache = DataCache()\n        with cache.getfile(key, suffix=suffix) as location:\n            inst = dlite.Instance.from_location(\n                driver=driver,\n                location=str(location),\n                options=config.options,\n                id=config.id,\n            )\n\n    # Insert inst into collection\n    coll = get_collection(session)\n    coll.add(config.label, inst)\n\n    # __TODO__\n    # See\n    # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185\n    # and following comments.\n    #\n    # Since we cannot safely assume that all strategies in a\n    # pipeline will be executed in the same Python interpreter,\n    # the collection should be written to a storage, such that it\n    # can be shared with the other strategies.\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel","title":"<code>parse_excel</code>","text":"<p>Strategy for parsing an Excel spreadsheet to a DLite instance.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig","title":"<code>DLiteExcelParseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for DLite Excel parser.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelParseConfig(AttrDict):\n    \"\"\"Configuration for DLite Excel parser.\"\"\"\n\n    metadata: Annotated[\n        Optional[HttpUrl],\n        Field(\n            description=(\n                \"URI of DLite metadata to return.  If not provided, the \"\n                \"metadata will be inferred from the excel file.\"\n            ),\n        ),\n    ] = None\n\n    id: Annotated[\n        Optional[str], Field(description=\"Optional id on new instance.\")\n    ] = None\n\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=\"Optional label for new instance in collection.\",\n        ),\n    ] = \"excel-data\"\n\n    excel_config: Annotated[\n        XLSXParseConfig,\n        Field(\n            description=\"DLite-specific excel configurations.\",\n        ),\n    ]\n    storage_path: Annotated[\n        Optional[str],\n        Field(\n            description=\"Path to metadata storage\",\n        ),\n    ] = None\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.excel_config","title":"<code>excel_config: Annotated[XLSXParseConfig, Field(description='DLite-specific excel configurations.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.id","title":"<code>id: Annotated[Optional[str], Field(description='Optional id on new instance.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Optional label for new instance in collection.')] = 'excel-data'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.metadata","title":"<code>metadata: Annotated[Optional[HttpUrl], Field(description='URI of DLite metadata to return.  If not provided, the metadata will be inferred from the excel file.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.storage_path","title":"<code>storage_path: Annotated[Optional[str], Field(description='Path to metadata storage')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig","title":"<code>DLiteExcelParseResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>DLite excel parse strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelParseResourceConfig(ResourceConfig):\n    \"\"\"DLite excel parse strategy resource config.\"\"\"\n\n    configuration: Annotated[\n        DLiteExcelParseConfig,\n        Field(description=\"DLite excel parse strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig.configuration","title":"<code>configuration: Annotated[DLiteExcelParseConfig, Field(description='DLite excel parse strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate","title":"<code>DLiteExcelSessionUpdate</code>","text":"<p>               Bases: <code>DLiteSessionUpdate</code></p> <p>Class for returning values from DLite excel parser.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelSessionUpdate(DLiteSessionUpdate):\n    \"\"\"Class for returning values from DLite excel parser.\"\"\"\n\n    inst_uuid: Annotated[\n        str,\n        Field(\n            description=\"UUID of new instance.\",\n        ),\n    ]\n    label: Annotated[\n        str,\n        Field(\n            description=\"Label of the new instance in the collection.\",\n        ),\n    ]\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate.inst_uuid","title":"<code>inst_uuid: Annotated[str, Field(description='UUID of new instance.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate.label","title":"<code>label: Annotated[str, Field(description='Label of the new instance in the collection.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy","title":"<code>DLiteExcelStrategy</code>","text":"<p>Parse strategy for Excel files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\",     \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>@dataclass\nclass DLiteExcelStrategy:\n    \"\"\"Parse strategy for Excel files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\",\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")`\n\n    \"\"\"\n\n    parse_config: DLiteExcelParseResourceConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteExcelSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            DLite instance.\n\n        \"\"\"\n        config = self.parse_config.configuration\n\n        xlsx_config = self.parse_config.model_dump()\n        xlsx_config[\"configuration\"] = config.excel_config\n        xlsx_config[\"mediaType\"] = (\n            \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n        )\n        parser: \"IParseStrategy\" = XLSXParseStrategy(xlsx_config)\n        columns: dict[str, \"Any\"] = parser.get(session)[\"data\"]\n\n        names, units = zip(\n            *[split_column_name(column) for column in columns.keys()]\n        )\n        rec = dict2recarray(columns, names=names)\n\n        if not isinstance(units, (list, tuple)):\n            # This check is to satisfy mypy for the `infer_metadata` call below.\n            raise TypeError(\n                f\"units must be a list or tuple, instead it was {type(units)}\"\n            )\n\n        if config.metadata:\n            if config.storage_path is not None:\n                for storage_path in config.storage_path.split(\"|\"):\n                    dlite.storage_path.append(storage_path)\n            meta = dlite.get_instance(config.metadata)\n            # check the metadata config would go here\n        else:\n            meta = infer_metadata(rec, units=units)\n\n        inst = meta(dimensions=[len(rec)], id=config.id)\n        for name in names:\n            inst[name] = rec[name]\n\n        # Insert inst into collection\n        coll = get_collection(session)\n        coll.add(config.label, inst)\n\n        update_collection(coll)\n        return DLiteExcelSessionUpdate(\n            collection_id=coll.uuid,\n            inst_uuid=inst.uuid,\n            label=config.label,\n        )\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.parse_config","title":"<code>parse_config: DLiteExcelParseResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteExcelSessionUpdate</code> <p>DLite instance.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteExcelSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        DLite instance.\n\n    \"\"\"\n    config = self.parse_config.configuration\n\n    xlsx_config = self.parse_config.model_dump()\n    xlsx_config[\"configuration\"] = config.excel_config\n    xlsx_config[\"mediaType\"] = (\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    )\n    parser: \"IParseStrategy\" = XLSXParseStrategy(xlsx_config)\n    columns: dict[str, \"Any\"] = parser.get(session)[\"data\"]\n\n    names, units = zip(\n        *[split_column_name(column) for column in columns.keys()]\n    )\n    rec = dict2recarray(columns, names=names)\n\n    if not isinstance(units, (list, tuple)):\n        # This check is to satisfy mypy for the `infer_metadata` call below.\n        raise TypeError(\n            f\"units must be a list or tuple, instead it was {type(units)}\"\n        )\n\n    if config.metadata:\n        if config.storage_path is not None:\n            for storage_path in config.storage_path.split(\"|\"):\n                dlite.storage_path.append(storage_path)\n        meta = dlite.get_instance(config.metadata)\n        # check the metadata config would go here\n    else:\n        meta = infer_metadata(rec, units=units)\n\n    inst = meta(dimensions=[len(rec)], id=config.id)\n    for name in names:\n        inst[name] = rec[name]\n\n    # Insert inst into collection\n    coll = get_collection(session)\n    coll.add(config.label, inst)\n\n    update_collection(coll)\n    return DLiteExcelSessionUpdate(\n        collection_id=coll.uuid,\n        inst_uuid=inst.uuid,\n        label=config.label,\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.infer_metadata","title":"<code>infer_metadata(rec, units)</code>","text":"<p>Infer dlite metadata from recarray <code>rec</code>.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def infer_metadata(rec: np.recarray, units: tuple[str, ...]) -&gt; dlite.Instance:\n    \"\"\"Infer dlite metadata from recarray `rec`.\"\"\"\n    rnd = getrandbits(128)\n    uri = f\"http://onto-ns.com/meta/1.0/generated_from_excel_{rnd:0x}\"\n    metadata = DataModel(\n        uri,\n        description=\"Generated datamodel from excel file.\",\n    )\n    metadata.add_dimension(\"nrows\", \"Number of rows.\")\n    for i, name in enumerate(rec.dtype.names):\n        dtype = rec[name].dtype\n        ptype = \"string\" if dtype.kind == \"U\" else dtype.name\n        metadata.add_property(name, type=ptype, shape=[\"nrows\"], unit=units[i])\n    return metadata.get()\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.split_column_name","title":"<code>split_column_name(column)</code>","text":"<p>Split column name into a (name, unit) tuple.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def split_column_name(column: str) -&gt; tuple[str, str]:\n    \"\"\"Split column name into a (name, unit) tuple.\"\"\"\n    match = re.match(r\"\\s*([^ ([&lt;]+)\\s*[([&lt;]?([^] )&gt;]*)[])&gt;]?\", column)\n    if not match:\n        return column, \"\"\n    name, unit = match.groups()\n    return name, unit\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image","title":"<code>parse_image</code>","text":"<p>Strategy class for parsing an image to a DLite instance.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.LOGGER","title":"<code>LOGGER = logging.getLogger('oteapi_dlite.strategies')</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageConfig","title":"<code>DLiteImageConfig</code>","text":"<p>               Bases: <code>ImageParserConfig</code></p> <p>Configuration for DLite image parser.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>class DLiteImageConfig(ImageParserConfig):\n    \"\"\"Configuration for DLite image parser.\"\"\"\n\n    image_label: Annotated[\n        str,\n        Field(\n            description=\"Label to assign to the image in the collection.\",\n        ),\n    ] = \"image\"\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageConfig.image_label","title":"<code>image_label: Annotated[str, Field(description='Label to assign to the image in the collection.')] = 'image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy","title":"<code>DLiteImageParseStrategy</code>","text":"<p>Parse strategy for image files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"image/vnd.dlite-gif\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jpeg\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jpg\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jp2\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-png\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-tiff\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>@dataclass\nclass DLiteImageParseStrategy:\n    \"\"\"Parse strategy for image files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"image/vnd.dlite-gif\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jpeg\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jpg\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jp2\")`\n    - `(\"mediaType\", \"image/vnd.dlite-png\")`\n    - `(\"mediaType\", \"image/vnd.dlite-tiff\")`\n\n    \"\"\"\n\n    parse_config: DLiteImageResourceConfig\n\n    def initialize(\n        self, session: \"Optional[dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific\n        endpoint of the OTE-API Services.  It assumes that the image to\n        parse is stored in a data cache, and can be retrieved via a key\n        that is supplied in either the session (highest priority)\n        or in the parser configuration (lowest priority).\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            DLite instance.\n        \"\"\"\n        config = self.parse_config.configuration\n\n        # Configuration for ImageDataParseStrategy in oteapi-core\n        conf = self.parse_config.model_dump()\n        conf[\"configuration\"] = ImageParserConfig(\n            **config.model_dump(), extra=\"ignore\"\n        )\n        conf[\"mediaType\"] = \"image/\" + conf[\"mediaType\"].split(\"-\")[-1]\n        core_config = ImageParserResourceConfig(**conf)\n\n        parse_strategy_session = ImageDataParseStrategy(core_config).initialize(\n            session\n        )\n        output = ImageDataParseStrategy(core_config).get(parse_strategy_session)\n\n        cache = DataCache()\n        data = cache.get(output[\"image_key\"])\n        if isinstance(data, bytes):\n            data = np.asarray(\n                Image.frombytes(\n                    data=data,\n                    mode=output[\"image_mode\"],\n                    size=output[\"image_size\"],\n                )\n            )\n        if not isinstance(data, np.ndarray):\n            raise TypeError(\n                \"Expected image data to be a numpy array, instead it was \"\n                f\"{type(data)}.\"\n            )\n\n        meta = get_meta(\"http://onto-ns.com/meta/1.0/Image\")\n        inst = meta(dimensions=data.shape)\n        inst[\"data\"] = data\n\n        LOGGER.info(\"session: %s\", session)\n\n        coll = get_collection(session)\n        coll.add(config.image_label, inst)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.parse_config","title":"<code>parse_config: DLiteImageResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.  It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority).</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>DLite instance.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>def get(\n    self, session: \"Optional[dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific\n    endpoint of the OTE-API Services.  It assumes that the image to\n    parse is stored in a data cache, and can be retrieved via a key\n    that is supplied in either the session (highest priority)\n    or in the parser configuration (lowest priority).\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        DLite instance.\n    \"\"\"\n    config = self.parse_config.configuration\n\n    # Configuration for ImageDataParseStrategy in oteapi-core\n    conf = self.parse_config.model_dump()\n    conf[\"configuration\"] = ImageParserConfig(\n        **config.model_dump(), extra=\"ignore\"\n    )\n    conf[\"mediaType\"] = \"image/\" + conf[\"mediaType\"].split(\"-\")[-1]\n    core_config = ImageParserResourceConfig(**conf)\n\n    parse_strategy_session = ImageDataParseStrategy(core_config).initialize(\n        session\n    )\n    output = ImageDataParseStrategy(core_config).get(parse_strategy_session)\n\n    cache = DataCache()\n    data = cache.get(output[\"image_key\"])\n    if isinstance(data, bytes):\n        data = np.asarray(\n            Image.frombytes(\n                data=data,\n                mode=output[\"image_mode\"],\n                size=output[\"image_size\"],\n            )\n        )\n    if not isinstance(data, np.ndarray):\n        raise TypeError(\n            \"Expected image data to be a numpy array, instead it was \"\n            f\"{type(data)}.\"\n        )\n\n    meta = get_meta(\"http://onto-ns.com/meta/1.0/Image\")\n    inst = meta(dimensions=data.shape)\n    inst[\"data\"] = data\n\n    LOGGER.info(\"session: %s\", session)\n\n    coll = get_collection(session)\n    coll.add(config.image_label, inst)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>def initialize(\n    self, session: \"Optional[dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageResourceConfig","title":"<code>DLiteImageResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>Resource config for DLite image parser.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>class DLiteImageResourceConfig(ResourceConfig):\n    \"\"\"Resource config for DLite image parser.\"\"\"\n\n    configuration: Annotated[\n        DLiteImageConfig,\n        Field(\n            description=\"Image parse strategy-specific configuration.\",\n        ),\n    ] = DLiteImageConfig()\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageResourceConfig.configuration","title":"<code>configuration: Annotated[DLiteImageConfig, Field(description='Image parse strategy-specific configuration.')] = DLiteImageConfig()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.serialise","title":"<code>serialise</code>","text":"<p>Filter for serialisation using DLite.</p>"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseConfig","title":"<code>SerialiseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>DLite serialise-specific configurations.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>class SerialiseConfig(AttrDict):\n    \"\"\"DLite serialise-specific configurations.\"\"\"\n\n    driver: Annotated[\n        str,\n        Field(\n            description=\"Name of DLite plugin used for serialisation.\",\n        ),\n    ]\n    location: Annotated[\n        Path,\n        Field(\n            description=\"Path or URL to serialise to.\",\n        ),\n    ]\n    options: Annotated[\n        Optional[str],\n        Field(\n            description=\"Options passed to the driver.\",\n        ),\n    ] = \"\"\n    labels: Annotated[\n        Optional[Sequence[str]],\n        Field(\n            None,\n            description=(\n                \"Optional sequence of labels in the collection to serialise.  \"\n                \"The default is to serialise the entire collection.\"\n            ),\n        ),\n    ] = None\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseConfig.driver","title":"<code>driver: Annotated[str, Field(description='Name of DLite plugin used for serialisation.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseConfig.labels","title":"<code>labels: Annotated[Optional[Sequence[str]], Field(None, description='Optional sequence of labels in the collection to serialise.  The default is to serialise the entire collection.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseConfig.location","title":"<code>location: Annotated[Path, Field(description='Path or URL to serialise to.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseConfig.options","title":"<code>options: Annotated[Optional[str], Field(description='Options passed to the driver.')] = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig","title":"<code>SerialiseFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>Filter config for serialise.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>class SerialiseFilterConfig(FilterConfig):\n    \"\"\"Filter config for serialise.\"\"\"\n\n    configuration: Annotated[\n        SerialiseConfig,\n        Field(\n            description=\"Serialise-specific configurations.\",\n        ),\n    ]\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig.configuration","title":"<code>configuration: Annotated[SerialiseConfig, Field(description='Serialise-specific configurations.')]</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseStrategy","title":"<code>SerialiseStrategy</code>","text":"<p>Filter for serialisation using DLite.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"dlite_serialise\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>@dataclass\nclass SerialiseStrategy:\n    \"\"\"Filter for serialisation using DLite.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"dlite_serialise\")`\n\n    \"\"\"\n\n    filter_config: SerialiseFilterConfig\n\n    def initialize(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\"\"\"\n        config = self.filter_config.configuration\n\n        coll = get_collection(session)\n\n        storage = dlite.Storage(\n            driver_or_url=config.driver,\n            location=str(config.location),\n            options=config.options,\n        )\n        if config.labels is None:\n            coll.save_to_storage(storage)\n        else:\n            for label in config.labels:\n                inst = coll.get(label)\n                inst.save_to_storage(storage)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseStrategy.filter_config","title":"<code>filter_config: SerialiseFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\"\"\"\n    config = self.filter_config.configuration\n\n    coll = get_collection(session)\n\n    storage = dlite.Storage(\n        driver_or_url=config.driver,\n        location=str(config.location),\n        options=config.options,\n    )\n    if config.labels is None:\n        coll.save_to_storage(storage)\n    else:\n        for label in config.labels:\n            inst = coll.get(label)\n            inst.save_to_storage(storage)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>def initialize(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/models/session/","title":"session","text":"<p>Pydantic data models for DLite.</p>"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate","title":"<code>DLiteSessionUpdate</code>","text":"<p>               Bases: <code>SessionUpdate</code></p> <p>Class for returning values from DLite strategies.</p> Source code in <code>oteapi_dlite/models/session.py</code> <pre><code>class DLiteSessionUpdate(SessionUpdate):\n    \"\"\"Class for returning values from DLite strategies.\"\"\"\n\n    collection_id: Annotated[\n        Optional[str], Field(description=\"A reference to a DLite collection.\")\n    ] = None\n</code></pre>"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate.collection_id","title":"<code>collection_id: Annotated[Optional[str], Field(description='A reference to a DLite collection.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/","title":"convert","text":"<p>Generic function strategy that converts zero or more input instances to zero or more new output instances.</p>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertConfig","title":"<code>DLiteConvertConfig</code>","text":"<p>               Bases: <code>FunctionConfig</code></p> <p>DLite convert strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertConfig(FunctionConfig):\n    \"\"\"DLite convert strategy resource config.\"\"\"\n\n    configuration: Annotated[\n        DLiteConvertStrategyConfig,\n        Field(description=\"DLite convert strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertConfig.configuration","title":"<code>configuration: Annotated[DLiteConvertStrategyConfig, Field(description='DLite convert strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig","title":"<code>DLiteConvertInputConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for input instance to generic DLite converter.</p> <p>At least one of <code>label</code> or <code>datamodel</code> should be given.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertInputConfig(AttrDict):\n    \"\"\"Configuration for input instance to generic DLite converter.\n\n    At least one of `label` or `datamodel` should be given.\n    \"\"\"\n\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=\"Label of the instance.\",\n        ),\n    ] = None\n    datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=\"URI of data model.\",\n        ),\n    ] = None\n    property_mappings: Annotated[\n        bool,\n        Field(\n            description=\"Whether to infer instance from property mappings.\",\n        ),\n    ] = False\n</code></pre>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig.datamodel","title":"<code>datamodel: Annotated[Optional[str], Field(description='URI of data model.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Label of the instance.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertInputConfig.property_mappings","title":"<code>property_mappings: Annotated[bool, Field(description='Whether to infer instance from property mappings.')] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertOutputConfig","title":"<code>DLiteConvertOutputConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for output instance to generic DLite converter.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertOutputConfig(AttrDict):\n    \"\"\"Configuration for output instance to generic DLite converter.\"\"\"\n\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=\"Label to use when storing the instance.\",\n        ),\n    ] = None\n    datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=\"URI of data model.  Used for documentation.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertOutputConfig.datamodel","title":"<code>datamodel: Annotated[Optional[str], Field(description='URI of data model.  Used for documentation.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertOutputConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Label to use when storing the instance.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategy","title":"<code>DLiteConvertStrategy</code>","text":"<p>Generic DLite convert strategy for converting zero or more input instances to zero or more output instances.</p> <p>Registers strategies:</p> <ul> <li><code>(\"functionType\", \"application/vnd.dlite-convert\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>@dataclass\nclass DLiteConvertStrategy:\n    \"\"\"Generic DLite convert strategy for converting zero or more input\n    instances to zero or more output instances.\n\n    **Registers strategies**:\n\n    - `(\"functionType\", \"application/vnd.dlite-convert\")`\n\n    \"\"\"\n\n    convert_config: DLiteConvertConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.convert_config.configuration\n\n        module = importlib.import_module(config.module_name, config.package)\n        function = getattr(module, config.function_name)\n\n        coll = get_collection(session)\n\n        instances = []\n        for i, input_config in enumerate(config.inputs):\n            input_config = config.inputs[i]\n            if input_config.label:\n                instances.append(\n                    coll.get(input_config.label, input_config.datamodel)\n                )\n            elif input_config.datamodel:\n                inst = coll.get_instances(\n                    metaid=input_config.datamodel,\n                    property_mappings=input_config.property_mappings,\n                    # More to do: add more arguments...\n                )\n            else:\n                raise ValueError(\n                    \"either `label` or `datamodel` must be specified in \"\n                    f\"inputs[{i}]\"\n                )\n\n        outputs = function(*instances)\n        if isinstance(outputs, dlite.Instance):\n            outputs = [outputs]\n\n        for inst, output_config in zip(outputs, config.outputs):\n            coll.add(output_config.label, inst)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategy.convert_config","title":"<code>convert_config: DLiteConvertConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.convert_config.configuration\n\n    module = importlib.import_module(config.module_name, config.package)\n    function = getattr(module, config.function_name)\n\n    coll = get_collection(session)\n\n    instances = []\n    for i, input_config in enumerate(config.inputs):\n        input_config = config.inputs[i]\n        if input_config.label:\n            instances.append(\n                coll.get(input_config.label, input_config.datamodel)\n            )\n        elif input_config.datamodel:\n            inst = coll.get_instances(\n                metaid=input_config.datamodel,\n                property_mappings=input_config.property_mappings,\n                # More to do: add more arguments...\n            )\n        else:\n            raise ValueError(\n                \"either `label` or `datamodel` must be specified in \"\n                f\"inputs[{i}]\"\n            )\n\n    outputs = function(*instances)\n    if isinstance(outputs, dlite.Instance):\n        outputs = [outputs]\n\n    for inst, output_config in zip(outputs, config.outputs):\n        coll.add(output_config.label, inst)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig","title":"<code>DLiteConvertStrategyConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for generic DLite converter.</p> Source code in <code>oteapi_dlite/strategies/convert.py</code> <pre><code>class DLiteConvertStrategyConfig(AttrDict):\n    \"\"\"Configuration for generic DLite converter.\"\"\"\n\n    function_name: Annotated[\n        str,\n        Field(\n            description=\"Name of convert function.  It will be pased the input \"\n            \"instances as arguments and should return a sequence of output \"\n            \"instances.\",\n        ),\n    ]\n    module_name: Annotated[\n        str,\n        Field(\n            description=(\n                \"Name of Python module containing the convertion function.\"\n            ),\n        ),\n    ]\n    package: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Used when performing a relative import of the converter \"\n                \"function.  It specifies the package to use as the anchor \"\n                \"point from which to resolve the relative import to an absolute\"\n                \" import.\"\n            ),\n        ),\n    ] = None\n    pypi_package: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Package name on PyPI.  This field is currently only \"\n                \"informative, but might be used in the future for automatic \"\n                \"package installation.\"\n            ),\n        ),\n    ] = None\n    inputs: Annotated[\n        Sequence[DLiteConvertInputConfig],\n        Field(\n            description=\"Input instances.\",\n        ),\n    ] = []\n    outputs: Annotated[\n        Sequence[DLiteConvertOutputConfig],\n        Field(\n            description=\"Output instances.\",\n        ),\n    ] = []\n</code></pre>"},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.function_name","title":"<code>function_name: Annotated[str, Field(description='Name of convert function.  It will be pased the input instances as arguments and should return a sequence of output instances.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.inputs","title":"<code>inputs: Annotated[Sequence[DLiteConvertInputConfig], Field(description='Input instances.')] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.module_name","title":"<code>module_name: Annotated[str, Field(description='Name of Python module containing the convertion function.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.outputs","title":"<code>outputs: Annotated[Sequence[DLiteConvertOutputConfig], Field(description='Output instances.')] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.package","title":"<code>package: Annotated[Optional[str], Field(description='Used when performing a relative import of the converter function.  It specifies the package to use as the anchor point from which to resolve the relative import to an absolute import.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/convert/#oteapi_dlite.strategies.convert.DLiteConvertStrategyConfig.pypi_package","title":"<code>pypi_package: Annotated[Optional[str], Field(description='Package name on PyPI.  This field is currently only informative, but might be used in the future for automatic package installation.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/","title":"filter","text":"<p>Filter that removes all but specified instances in the collection.</p>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteFilterConfig","title":"<code>DLiteFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>DLite generate strategy config.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>class DLiteFilterConfig(FilterConfig):\n    \"\"\"DLite generate strategy config.\"\"\"\n\n    configuration: Annotated[\n        DLiteQueryConfig,\n        Field(description=\"DLite filter strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteFilterConfig.configuration","title":"<code>configuration: Annotated[DLiteQueryConfig, Field(description='DLite filter strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteFilterStrategy","title":"<code>DLiteFilterStrategy</code>","text":"<p>Filter that removes all but specified instances in the collection.</p> <p>The <code>query</code> configuration should be a regular expression matching labels to keep in the collection.  All other labels will be removed.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"dlite/filter\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>@dataclass\nclass DLiteFilterStrategy:\n    \"\"\"Filter that removes all but specified instances in the collection.\n\n    The `query` configuration should be a regular expression matching labels\n    to keep in the collection.  All other labels will be removed.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"dlite/filter\")`\n\n    \"\"\"\n\n    filter_config: DLiteFilterConfig\n\n    def initialize(\n        self,\n        session: \"Optional[dict[str, Any]]\" = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\"\"\"\n        # pylint: disable=too-many-branches\n        config = self.filter_config.configuration\n\n        # Alias for query configuration\n        keep_label = (\n            config.keep_label if config.keep_label else self.filter_config.query\n        )\n\n        instdict = {}  # Map instance labels to [uuid, metaURI]\n        coll = get_collection(session)\n        for s, _, o in coll.get_relations(p=\"_has-uuid\"):\n            instdict[s] = [o]\n        for s, _, o in coll.get_relations(p=\"_has-meta\"):\n            instdict[s].append(o)\n\n        removal = set()  # Labels marked for removal\n\n        # 1: remove_label, remove_datamodel\n        if config.remove_label or config.remove_datamodel:\n            for label, (_, metauri) in instdict.items():\n                if config.remove_label and re.match(config.remove_label, label):\n                    removal.add(label)\n\n                if config.remove_datamodel and re.match(\n                    config.remove_datamodel, metauri\n                ):\n                    removal.add(label)\n        else:\n            removal.update(instdict.keys())\n\n        # 2: keep_label, keep_datamodel\n        for label in set(removal):\n            if keep_label and re.match(keep_label, label):\n                removal.remove(label)\n\n            _, metauri = instdict[label]\n            if config.keep_datamodel and re.match(\n                config.keep_datamodel, metauri\n            ):\n                removal.remove(label)\n\n        # 3: keep_referred\n        if config.keep_referred:\n            labels = {uuid: label for label, (uuid, _) in instdict.items()}\n            kept = set(instdict.keys()).difference(removal)\n            for label in kept:\n                removal.difference_update(\n                    labels[inst.uuid]\n                    for inst in get_referred_instances(coll.get(label))\n                    if inst.uuid in labels\n                )\n\n        # 4: remove from collection\n        for label in removal:\n            coll.remove(label)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteFilterStrategy.filter_config","title":"<code>filter_config: DLiteFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteFilterStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>def get(\n    self, session: \"Optional[dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\"\"\"\n    # pylint: disable=too-many-branches\n    config = self.filter_config.configuration\n\n    # Alias for query configuration\n    keep_label = (\n        config.keep_label if config.keep_label else self.filter_config.query\n    )\n\n    instdict = {}  # Map instance labels to [uuid, metaURI]\n    coll = get_collection(session)\n    for s, _, o in coll.get_relations(p=\"_has-uuid\"):\n        instdict[s] = [o]\n    for s, _, o in coll.get_relations(p=\"_has-meta\"):\n        instdict[s].append(o)\n\n    removal = set()  # Labels marked for removal\n\n    # 1: remove_label, remove_datamodel\n    if config.remove_label or config.remove_datamodel:\n        for label, (_, metauri) in instdict.items():\n            if config.remove_label and re.match(config.remove_label, label):\n                removal.add(label)\n\n            if config.remove_datamodel and re.match(\n                config.remove_datamodel, metauri\n            ):\n                removal.add(label)\n    else:\n        removal.update(instdict.keys())\n\n    # 2: keep_label, keep_datamodel\n    for label in set(removal):\n        if keep_label and re.match(keep_label, label):\n            removal.remove(label)\n\n        _, metauri = instdict[label]\n        if config.keep_datamodel and re.match(\n            config.keep_datamodel, metauri\n        ):\n            removal.remove(label)\n\n    # 3: keep_referred\n    if config.keep_referred:\n        labels = {uuid: label for label, (uuid, _) in instdict.items()}\n        kept = set(instdict.keys()).difference(removal)\n        for label in kept:\n            removal.difference_update(\n                labels[inst.uuid]\n                for inst in get_referred_instances(coll.get(label))\n                if inst.uuid in labels\n            )\n\n    # 4: remove from collection\n    for label in removal:\n        coll.remove(label)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteFilterStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[dict[str, Any]]\" = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteQueryConfig","title":"<code>DLiteQueryConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for the DLite filter strategy.</p> <p>First the <code>remove_label</code> and <code>remove_datamodel</code> configurations are used to mark matching instances for removal.  If neither <code>remove_label</code> or <code>remove_datamodel</code> are given, all instances are marked for removal.</p> <p>Then instances matching <code>keep_label</code> and <code>keep_datamodel</code> are unmarked for removal.</p> <p>If <code>keep_referred</code> is true, any instance that is referred to by an instance not marked for removal is also unmarked for removal.</p> <p>Finally, the instances that are still marked for removal are removed from the collection.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>class DLiteQueryConfig(AttrDict):\n    \"\"\"Configuration for the DLite filter strategy.\n\n    First the `remove_label` and `remove_datamodel` configurations are\n    used to mark matching instances for removal.  If neither\n    `remove_label` or `remove_datamodel` are given, all instances are\n    marked for removal.\n\n    Then instances matching `keep_label` and `keep_datamodel` are unmarked\n    for removal.\n\n    If `keep_referred` is true, any instance that is referred to by\n    an instance not marked for removal is also unmarked for removal.\n\n    Finally, the instances that are still marked for removal are removed\n    from the collection.\n    \"\"\"\n\n    remove_label: Annotated[\n        Optional[str],\n        Field(description=\"Regular expression matching labels to remove.\"),\n    ] = None\n    remove_datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=\"Regular expression matching datamodel URIs to remove.\",\n        ),\n    ] = None\n    keep_label: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Regular expression matching labels to keep. This \"\n                \"configuration overrides `remove_label` and \"\n                \"`remove_datamodel`. Alias for the FilterStrategy `query` \"\n                \"configuration, that is inherited from the oteapi-core Filter \"\n                \"data model.\"\n            ),\n        ),\n    ] = None\n    keep_datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Regular expression matching datamodel URIs to keep in \"\n                \"collection. This configuration overrides `remove_label` and \"\n                \"`remove_datamodel`.\"\n            ),\n        ),\n    ] = None\n    keep_referred: Annotated[\n        bool,\n        Field(\n            description=(\n                \"Whether to keep all instances in the collection that are \"\n                \"directly or indirectly referred to (via ref-types or \"\n                \"collections) by kept instances.\"\n            ),\n        ),\n    ] = True\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteQueryConfig.keep_datamodel","title":"<code>keep_datamodel: Annotated[Optional[str], Field(description='Regular expression matching datamodel URIs to keep in collection. This configuration overrides `remove_label` and `remove_datamodel`.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteQueryConfig.keep_label","title":"<code>keep_label: Annotated[Optional[str], Field(description='Regular expression matching labels to keep. This configuration overrides `remove_label` and `remove_datamodel`. Alias for the FilterStrategy `query` configuration, that is inherited from the oteapi-core Filter data model.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteQueryConfig.keep_referred","title":"<code>keep_referred: Annotated[bool, Field(description='Whether to keep all instances in the collection that are directly or indirectly referred to (via ref-types or collections) by kept instances.')] = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteQueryConfig.remove_datamodel","title":"<code>remove_datamodel: Annotated[Optional[str], Field(description='Regular expression matching datamodel URIs to remove.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.DLiteQueryConfig.remove_label","title":"<code>remove_label: Annotated[Optional[str], Field(description='Regular expression matching labels to remove.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/","title":"generate","text":"<p>Generic generate strategy using DLite storage plugin.</p>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateConfig","title":"<code>DLiteGenerateConfig</code>","text":"<p>               Bases: <code>FunctionConfig</code></p> <p>DLite generate strategy config.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>class DLiteGenerateConfig(FunctionConfig):\n    \"\"\"DLite generate strategy config.\"\"\"\n\n    configuration: Annotated[\n        DLiteStorageConfig,\n        Field(description=\"DLite generate strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateConfig.configuration","title":"<code>configuration: Annotated[DLiteStorageConfig, Field(description='DLite generate strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy","title":"<code>DLiteGenerateStrategy</code>","text":"<p>Generic DLite generate strategy utilising DLite storage plugins.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.dlite-generate\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>@dataclass\nclass DLiteGenerateStrategy:\n    \"\"\"Generic DLite generate strategy utilising DLite storage plugins.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.dlite-generate\")`\n\n    \"\"\"\n\n    generate_config: DLiteGenerateConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.generate_config.configuration\n        cacheconfig = config.datacache_config\n\n        driver = (\n            config.driver\n            if config.driver\n            else get_driver(\n                mediaType=config.mediaType,\n            )\n        )\n\n        coll = get_collection(session, config.collection_id)\n\n        if config.label:\n            inst = coll[config.label]\n        elif config.datamodel:\n            instances = coll.get_instances(\n                metaid=config.datamodel,\n                property_mappings=True,\n                allow_incomplete=config.allow_incomplete,\n            )\n            inst = next(instances)\n        elif config.store_collection:\n            if config.store_collection_id:\n                inst = coll.copy(newid=config.store_collection_id)\n            else:\n                inst = coll\n        else:  # fail if there are more instances\n            raise ValueError(\n                \"One of `label` or `datamodel` configurations should be given.\"\n            )\n\n        # Save instance\n        if config.location:\n            inst.save(driver, config.location, config.options)\n        else:  # missing test\n            if cacheconfig and cacheconfig.accessKey:\n                key = cacheconfig.accessKey\n            else:  # missing test\n                key = \"generate_data\"\n            cache = DataCache()\n            with tempfile.TemporaryDirectory() as tmpdir:\n                inst.save(driver, \"{tmpdir}/data\", config.options)\n                with open(f\"{tmpdir}/data\", \"rb\") as f:\n                    cache.add(f.read(), key=key)\n\n        # __TODO__\n        # Can we safely assume that all strategies in a pipeline will be\n        # executed in the same Python interpreter?  If not, we should write\n        # the collection to a storage, such that it can be shared with the\n        # other strategies.\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.generate_config","title":"<code>generate_config: DLiteGenerateConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.generate_config.configuration\n    cacheconfig = config.datacache_config\n\n    driver = (\n        config.driver\n        if config.driver\n        else get_driver(\n            mediaType=config.mediaType,\n        )\n    )\n\n    coll = get_collection(session, config.collection_id)\n\n    if config.label:\n        inst = coll[config.label]\n    elif config.datamodel:\n        instances = coll.get_instances(\n            metaid=config.datamodel,\n            property_mappings=True,\n            allow_incomplete=config.allow_incomplete,\n        )\n        inst = next(instances)\n    elif config.store_collection:\n        if config.store_collection_id:\n            inst = coll.copy(newid=config.store_collection_id)\n        else:\n            inst = coll\n    else:  # fail if there are more instances\n        raise ValueError(\n            \"One of `label` or `datamodel` configurations should be given.\"\n        )\n\n    # Save instance\n    if config.location:\n        inst.save(driver, config.location, config.options)\n    else:  # missing test\n        if cacheconfig and cacheconfig.accessKey:\n            key = cacheconfig.accessKey\n        else:  # missing test\n            key = \"generate_data\"\n        cache = DataCache()\n        with tempfile.TemporaryDirectory() as tmpdir:\n            inst.save(driver, \"{tmpdir}/data\", config.options)\n            with open(f\"{tmpdir}/data\", \"rb\") as f:\n                cache.add(f.read(), key=key)\n\n    # __TODO__\n    # Can we safely assume that all strategies in a pipeline will be\n    # executed in the same Python interpreter?  If not, we should write\n    # the collection to a storage, such that it can be shared with the\n    # other strategies.\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig","title":"<code>DLiteStorageConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for a generic DLite storage filter.</p> <p>The DLite storage driver to can be specified using either the <code>driver</code> or <code>mediaType</code> field.</p> <p>Where the output should be written, is specified using either the <code>location</code> or <code>datacache_config.accessKey</code> field.</p> <p>Either <code>label</code> or <code>datamodel</code> should be provided.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>class DLiteStorageConfig(AttrDict):\n    \"\"\"Configuration for a generic DLite storage filter.\n\n    The DLite storage driver to can be specified using either the `driver`\n    or `mediaType` field.\n\n    Where the output should be written, is specified using either the\n    `location` or `datacache_config.accessKey` field.\n\n    Either `label` or `datamodel` should be provided.\n    \"\"\"\n\n    driver: Annotated[\n        Optional[str],\n        Field(\n            description='Name of DLite driver (ex: \"json\").',\n        ),\n    ] = None\n    mediaType: Annotated[\n        Optional[str],\n        Field(\n            description='Media type for DLite driver (ex: \"application/json\").',\n        ),\n    ] = None\n    options: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Comma-separated list of options passed to the DLite \"\n                \"storage plugin.\"\n            ),\n        ),\n    ] = None\n    location: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Location of storage to write to.  If unset to store in data \"\n                \"cache using the key provided with \"\n                \"`datacache_config.accessKey` (defaults to 'generate_data').\"\n            ),\n        ),\n    ] = None\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Label of DLite instance in the collection to serialise.\"\n            ),\n        ),\n    ] = None\n    datamodel: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"URI to the datamodel of the new instance.  Needed when \"\n                \"generating the instance from mappings.  Cannot be combined \"\n                \"with `label`\"\n            ),\n        ),\n    ] = None\n    store_collection: Annotated[\n        bool,\n        Field(\n            description=\"Whether to store the entire collection in the session \"\n            \"instead of a single instance.  Cannot be combined with `label` or \"\n            \"`datamodel`.\",\n        ),\n    ] = False\n    store_collection_id: Annotated[\n        Optional[str],\n        Field(\n            description=\"Used together with `store_collection` If given, store \"\n            \"a copy of the collection with this id.\",\n        ),\n    ] = None\n    allow_incomplete: Annotated[\n        Optional[bool],\n        Field(\n            description=\"Whether to allow incomplete property mappings.\",\n        ),\n    ] = False\n    collection_id: Annotated[\n        Optional[str],\n        Field(\n            description=(\"ID of the collection to use.\"),\n        ),\n    ] = None\n    datacache_config: Annotated[\n        Optional[DataCacheConfig],\n        Field(\n            description=\"Configuration options for the local data cache.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.allow_incomplete","title":"<code>allow_incomplete: Annotated[Optional[bool], Field(description='Whether to allow incomplete property mappings.')] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.collection_id","title":"<code>collection_id: Annotated[Optional[str], Field(description='ID of the collection to use.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.datacache_config","title":"<code>datacache_config: Annotated[Optional[DataCacheConfig], Field(description='Configuration options for the local data cache.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.datamodel","title":"<code>datamodel: Annotated[Optional[str], Field(description='URI to the datamodel of the new instance.  Needed when generating the instance from mappings.  Cannot be combined with `label`')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.driver","title":"<code>driver: Annotated[Optional[str], Field(description='Name of DLite driver (ex: \"json\").')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Label of DLite instance in the collection to serialise.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.location","title":"<code>location: Annotated[Optional[str], Field(description=\"Location of storage to write to.  If unset to store in data cache using the key provided with `datacache_config.accessKey` (defaults to 'generate_data').\")] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.mediaType","title":"<code>mediaType: Annotated[Optional[str], Field(description='Media type for DLite driver (ex: \"application/json\").')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.options","title":"<code>options: Annotated[Optional[str], Field(description='Comma-separated list of options passed to the DLite storage plugin.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.store_collection","title":"<code>store_collection: Annotated[bool, Field(description='Whether to store the entire collection in the session instead of a single instance.  Cannot be combined with `label` or `datamodel`.')] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig.store_collection_id","title":"<code>store_collection_id: Annotated[Optional[str], Field(description='Used together with `store_collection` If given, store a copy of the collection with this id.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/","title":"mapping","text":"<p>Mapping filter strategy.</p>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingConfig","title":"<code>DLiteMappingConfig</code>","text":"<p>               Bases: <code>MappingConfig</code></p> <p>DLite mapping strategy config.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>class DLiteMappingConfig(MappingConfig):\n    \"\"\"DLite mapping strategy config.\"\"\"\n\n    configuration: Annotated[\n        DLiteMappingStrategyConfig,\n        Field(\n            description=\"DLite mapping strategy-specific configuration.\",\n        ),\n    ] = DLiteMappingStrategyConfig()\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingConfig.configuration","title":"<code>configuration: Annotated[DLiteMappingStrategyConfig, Field(description='DLite mapping strategy-specific configuration.')] = DLiteMappingStrategyConfig()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy","title":"<code>DLiteMappingStrategy</code>","text":"<p>Strategy for a mapping.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mappingType\", \"mappings\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>@dataclass\nclass DLiteMappingStrategy:\n    \"\"\"Strategy for a mapping.\n\n    **Registers strategies**:\n\n    - `(\"mappingType\", \"mappings\")`\n\n    \"\"\"\n\n    mapping_config: DLiteMappingConfig\n\n    def initialize(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize strategy.\"\"\"\n        coll = get_collection(session)\n        ts = Triplestore(backend=\"collection\", collection=coll)\n\n        if self.mapping_config.prefixes:\n            for prefix, iri in self.mapping_config.prefixes.items():\n                ts.bind(prefix, iri)\n\n        if self.mapping_config.triples:\n            ts.add_triples(\n                [\n                    [\n                        ts.expand_iri(t) if isinstance(t, str) else t\n                        for t in triple\n                    ]\n                    for triple in self.mapping_config.triples  # pylint: disable=not-an-iterable\n                ]\n            )\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute strategy and return a dictionary.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.mapping_config","title":"<code>mapping_config: DLiteMappingConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute strategy and return a dictionary.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>def initialize(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize strategy.\"\"\"\n    coll = get_collection(session)\n    ts = Triplestore(backend=\"collection\", collection=coll)\n\n    if self.mapping_config.prefixes:\n        for prefix, iri in self.mapping_config.prefixes.items():\n            ts.bind(prefix, iri)\n\n    if self.mapping_config.triples:\n        ts.add_triples(\n            [\n                [\n                    ts.expand_iri(t) if isinstance(t, str) else t\n                    for t in triple\n                ]\n                for triple in self.mapping_config.triples  # pylint: disable=not-an-iterable\n            ]\n        )\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategyConfig","title":"<code>DLiteMappingStrategyConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for a DLite mapping filter.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>class DLiteMappingStrategyConfig(AttrDict):\n    \"\"\"Configuration for a DLite mapping filter.\"\"\"\n\n    datamodel: Annotated[\n        Optional[AnyUrl],\n        Field(\n            description=\"URI of the datamodel that is mapped.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategyConfig.datamodel","title":"<code>datamodel: Annotated[Optional[AnyUrl], Field(description='URI of the datamodel that is mapped.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/","title":"parse","text":"<p>Generic parse strategy using DLite storage plugin.</p>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig","title":"<code>DLiteParseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for generic DLite parser.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>class DLiteParseConfig(AttrDict):\n    \"\"\"Configuration for generic DLite parser.\"\"\"\n\n    driver: Annotated[\n        Optional[str],\n        Field(\n            description='Name of DLite driver (ex: \"json\").',\n        ),\n    ] = None\n    location: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Explicit location of storage.  Normally data is read from the \"\n                \"data cache using `datacache_config.accessKey` (default: \"\n                \"'key').\"\n            ),\n        ),\n    ] = None\n    options: Annotated[\n        Optional[str],\n        Field(\n            description=(\n                \"Comma-separated list of options passed to the DLite storage \"\n                \"plugin.\"\n            ),\n        ),\n    ] = None\n    id: Annotated[\n        Optional[str],\n        Field(\n            description=\"If given, the id of the instance in the storage.\",\n        ),\n    ] = None\n    label: Annotated[\n        str,\n        Field(\n            description=\"Label of the new DLite instance in the collection.\",\n        ),\n    ]\n    datacache_config: Annotated[\n        Optional[DataCacheConfig],\n        Field(\n            description=\"Configuration options for the local data cache.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig.datacache_config","title":"<code>datacache_config: Annotated[Optional[DataCacheConfig], Field(description='Configuration options for the local data cache.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig.driver","title":"<code>driver: Annotated[Optional[str], Field(description='Name of DLite driver (ex: \"json\").')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig.id","title":"<code>id: Annotated[Optional[str], Field(description='If given, the id of the instance in the storage.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig.label","title":"<code>label: Annotated[str, Field(description='Label of the new DLite instance in the collection.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig.location","title":"<code>location: Annotated[Optional[str], Field(description=\"Explicit location of storage.  Normally data is read from the data cache using `datacache_config.accessKey` (default: 'key').\")] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig.options","title":"<code>options: Annotated[Optional[str], Field(description='Comma-separated list of options passed to the DLite storage plugin.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseResourceConfig","title":"<code>DLiteParseResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>DLite parse strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>class DLiteParseResourceConfig(ResourceConfig):\n    \"\"\"DLite parse strategy resource config.\"\"\"\n\n    configuration: Annotated[\n        DLiteParseConfig,\n        Field(description=\"DLite parse strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseResourceConfig.configuration","title":"<code>configuration: Annotated[DLiteParseConfig, Field(description='DLite parse strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy","title":"<code>DLiteParseStrategy</code>","text":"<p>Generic DLite parse strategy utilising DLite storage plugins.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.dlite-parse\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>@dataclass\nclass DLiteParseStrategy:\n    \"\"\"Generic DLite parse strategy utilising DLite storage plugins.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.dlite-parse\")`\n\n    \"\"\"\n\n    parse_config: DLiteParseResourceConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.parse_config.configuration\n        cacheconfig = config.datacache_config\n\n        driver = (\n            config.driver\n            if config.driver\n            else get_driver(\n                mediaType=self.parse_config.mediaType,\n            )\n        )\n\n        # Create instance\n        if config.location:\n            inst = dlite.Instance.from_location(\n                driver=driver,\n                location=config.location,\n                options=config.options,\n                id=config.id,\n            )\n        else:\n            if cacheconfig and cacheconfig.accessKey:\n                key = cacheconfig.accessKey\n            elif session and \"key\" in session:\n                key = session[\"key\"]\n            else:\n                raise ValueError(\n                    \"either `location` or `datacache_config.accessKey` must be \"\n                    \"provided\"\n                )\n\n            # See if we can extract file suffix from downloadUrl\n            if self.parse_config.downloadUrl:\n                suffix = Path(str(self.parse_config.downloadUrl)).suffix\n            else:\n                suffix = None\n\n            cache = DataCache()\n            with cache.getfile(key, suffix=suffix) as location:\n                inst = dlite.Instance.from_location(\n                    driver=driver,\n                    location=str(location),\n                    options=config.options,\n                    id=config.id,\n                )\n\n        # Insert inst into collection\n        coll = get_collection(session)\n        coll.add(config.label, inst)\n\n        # __TODO__\n        # See\n        # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185\n        # and following comments.\n        #\n        # Since we cannot safely assume that all strategies in a\n        # pipeline will be executed in the same Python interpreter,\n        # the collection should be written to a storage, such that it\n        # can be shared with the other strategies.\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy.parse_config","title":"<code>parse_config: DLiteParseResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.parse_config.configuration\n    cacheconfig = config.datacache_config\n\n    driver = (\n        config.driver\n        if config.driver\n        else get_driver(\n            mediaType=self.parse_config.mediaType,\n        )\n    )\n\n    # Create instance\n    if config.location:\n        inst = dlite.Instance.from_location(\n            driver=driver,\n            location=config.location,\n            options=config.options,\n            id=config.id,\n        )\n    else:\n        if cacheconfig and cacheconfig.accessKey:\n            key = cacheconfig.accessKey\n        elif session and \"key\" in session:\n            key = session[\"key\"]\n        else:\n            raise ValueError(\n                \"either `location` or `datacache_config.accessKey` must be \"\n                \"provided\"\n            )\n\n        # See if we can extract file suffix from downloadUrl\n        if self.parse_config.downloadUrl:\n            suffix = Path(str(self.parse_config.downloadUrl)).suffix\n        else:\n            suffix = None\n\n        cache = DataCache()\n        with cache.getfile(key, suffix=suffix) as location:\n            inst = dlite.Instance.from_location(\n                driver=driver,\n                location=str(location),\n                options=config.options,\n                id=config.id,\n            )\n\n    # Insert inst into collection\n    coll = get_collection(session)\n    coll.add(config.label, inst)\n\n    # __TODO__\n    # See\n    # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185\n    # and following comments.\n    #\n    # Since we cannot safely assume that all strategies in a\n    # pipeline will be executed in the same Python interpreter,\n    # the collection should be written to a storage, such that it\n    # can be shared with the other strategies.\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/","title":"parse_excel","text":"<p>Strategy for parsing an Excel spreadsheet to a DLite instance.</p>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig","title":"<code>DLiteExcelParseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration for DLite Excel parser.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelParseConfig(AttrDict):\n    \"\"\"Configuration for DLite Excel parser.\"\"\"\n\n    metadata: Annotated[\n        Optional[HttpUrl],\n        Field(\n            description=(\n                \"URI of DLite metadata to return.  If not provided, the \"\n                \"metadata will be inferred from the excel file.\"\n            ),\n        ),\n    ] = None\n\n    id: Annotated[\n        Optional[str], Field(description=\"Optional id on new instance.\")\n    ] = None\n\n    label: Annotated[\n        Optional[str],\n        Field(\n            description=\"Optional label for new instance in collection.\",\n        ),\n    ] = \"excel-data\"\n\n    excel_config: Annotated[\n        XLSXParseConfig,\n        Field(\n            description=\"DLite-specific excel configurations.\",\n        ),\n    ]\n    storage_path: Annotated[\n        Optional[str],\n        Field(\n            description=\"Path to metadata storage\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.excel_config","title":"<code>excel_config: Annotated[XLSXParseConfig, Field(description='DLite-specific excel configurations.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.id","title":"<code>id: Annotated[Optional[str], Field(description='Optional id on new instance.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.label","title":"<code>label: Annotated[Optional[str], Field(description='Optional label for new instance in collection.')] = 'excel-data'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.metadata","title":"<code>metadata: Annotated[Optional[HttpUrl], Field(description='URI of DLite metadata to return.  If not provided, the metadata will be inferred from the excel file.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig.storage_path","title":"<code>storage_path: Annotated[Optional[str], Field(description='Path to metadata storage')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig","title":"<code>DLiteExcelParseResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>DLite excel parse strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelParseResourceConfig(ResourceConfig):\n    \"\"\"DLite excel parse strategy resource config.\"\"\"\n\n    configuration: Annotated[\n        DLiteExcelParseConfig,\n        Field(description=\"DLite excel parse strategy-specific configuration.\"),\n    ]\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig.configuration","title":"<code>configuration: Annotated[DLiteExcelParseConfig, Field(description='DLite excel parse strategy-specific configuration.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate","title":"<code>DLiteExcelSessionUpdate</code>","text":"<p>               Bases: <code>DLiteSessionUpdate</code></p> <p>Class for returning values from DLite excel parser.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelSessionUpdate(DLiteSessionUpdate):\n    \"\"\"Class for returning values from DLite excel parser.\"\"\"\n\n    inst_uuid: Annotated[\n        str,\n        Field(\n            description=\"UUID of new instance.\",\n        ),\n    ]\n    label: Annotated[\n        str,\n        Field(\n            description=\"Label of the new instance in the collection.\",\n        ),\n    ]\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate.inst_uuid","title":"<code>inst_uuid: Annotated[str, Field(description='UUID of new instance.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate.label","title":"<code>label: Annotated[str, Field(description='Label of the new instance in the collection.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy","title":"<code>DLiteExcelStrategy</code>","text":"<p>Parse strategy for Excel files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\",     \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>@dataclass\nclass DLiteExcelStrategy:\n    \"\"\"Parse strategy for Excel files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\",\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")`\n\n    \"\"\"\n\n    parse_config: DLiteExcelParseResourceConfig\n\n    def initialize(\n        self,\n        session: Optional[dict[str, \"Any\"]] = None,\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteExcelSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            DLite instance.\n\n        \"\"\"\n        config = self.parse_config.configuration\n\n        xlsx_config = self.parse_config.model_dump()\n        xlsx_config[\"configuration\"] = config.excel_config\n        xlsx_config[\"mediaType\"] = (\n            \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n        )\n        parser: \"IParseStrategy\" = XLSXParseStrategy(xlsx_config)\n        columns: dict[str, \"Any\"] = parser.get(session)[\"data\"]\n\n        names, units = zip(\n            *[split_column_name(column) for column in columns.keys()]\n        )\n        rec = dict2recarray(columns, names=names)\n\n        if not isinstance(units, (list, tuple)):\n            # This check is to satisfy mypy for the `infer_metadata` call below.\n            raise TypeError(\n                f\"units must be a list or tuple, instead it was {type(units)}\"\n            )\n\n        if config.metadata:\n            if config.storage_path is not None:\n                for storage_path in config.storage_path.split(\"|\"):\n                    dlite.storage_path.append(storage_path)\n            meta = dlite.get_instance(config.metadata)\n            # check the metadata config would go here\n        else:\n            meta = infer_metadata(rec, units=units)\n\n        inst = meta(dimensions=[len(rec)], id=config.id)\n        for name in names:\n            inst[name] = rec[name]\n\n        # Insert inst into collection\n        coll = get_collection(session)\n        coll.add(config.label, inst)\n\n        update_collection(coll)\n        return DLiteExcelSessionUpdate(\n            collection_id=coll.uuid,\n            inst_uuid=inst.uuid,\n            label=config.label,\n        )\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.parse_config","title":"<code>parse_config: DLiteExcelParseResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteExcelSessionUpdate</code> <p>DLite instance.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteExcelSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        DLite instance.\n\n    \"\"\"\n    config = self.parse_config.configuration\n\n    xlsx_config = self.parse_config.model_dump()\n    xlsx_config[\"configuration\"] = config.excel_config\n    xlsx_config[\"mediaType\"] = (\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    )\n    parser: \"IParseStrategy\" = XLSXParseStrategy(xlsx_config)\n    columns: dict[str, \"Any\"] = parser.get(session)[\"data\"]\n\n    names, units = zip(\n        *[split_column_name(column) for column in columns.keys()]\n    )\n    rec = dict2recarray(columns, names=names)\n\n    if not isinstance(units, (list, tuple)):\n        # This check is to satisfy mypy for the `infer_metadata` call below.\n        raise TypeError(\n            f\"units must be a list or tuple, instead it was {type(units)}\"\n        )\n\n    if config.metadata:\n        if config.storage_path is not None:\n            for storage_path in config.storage_path.split(\"|\"):\n                dlite.storage_path.append(storage_path)\n        meta = dlite.get_instance(config.metadata)\n        # check the metadata config would go here\n    else:\n        meta = infer_metadata(rec, units=units)\n\n    inst = meta(dimensions=[len(rec)], id=config.id)\n    for name in names:\n        inst[name] = rec[name]\n\n    # Insert inst into collection\n    coll = get_collection(session)\n    coll.add(config.label, inst)\n\n    update_collection(coll)\n    return DLiteExcelSessionUpdate(\n        collection_id=coll.uuid,\n        inst_uuid=inst.uuid,\n        label=config.label,\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def initialize(\n    self,\n    session: Optional[dict[str, \"Any\"]] = None,\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.infer_metadata","title":"<code>infer_metadata(rec, units)</code>","text":"<p>Infer dlite metadata from recarray <code>rec</code>.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def infer_metadata(rec: np.recarray, units: tuple[str, ...]) -&gt; dlite.Instance:\n    \"\"\"Infer dlite metadata from recarray `rec`.\"\"\"\n    rnd = getrandbits(128)\n    uri = f\"http://onto-ns.com/meta/1.0/generated_from_excel_{rnd:0x}\"\n    metadata = DataModel(\n        uri,\n        description=\"Generated datamodel from excel file.\",\n    )\n    metadata.add_dimension(\"nrows\", \"Number of rows.\")\n    for i, name in enumerate(rec.dtype.names):\n        dtype = rec[name].dtype\n        ptype = \"string\" if dtype.kind == \"U\" else dtype.name\n        metadata.add_property(name, type=ptype, shape=[\"nrows\"], unit=units[i])\n    return metadata.get()\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.split_column_name","title":"<code>split_column_name(column)</code>","text":"<p>Split column name into a (name, unit) tuple.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def split_column_name(column: str) -&gt; tuple[str, str]:\n    \"\"\"Split column name into a (name, unit) tuple.\"\"\"\n    match = re.match(r\"\\s*([^ ([&lt;]+)\\s*[([&lt;]?([^] )&gt;]*)[])&gt;]?\", column)\n    if not match:\n        return column, \"\"\n    name, unit = match.groups()\n    return name, unit\n</code></pre>"},{"location":"api_reference/strategies/parse_image/","title":"parse_image","text":"<p>Strategy class for parsing an image to a DLite instance.</p>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.LOGGER","title":"<code>LOGGER = logging.getLogger('oteapi_dlite.strategies')</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageConfig","title":"<code>DLiteImageConfig</code>","text":"<p>               Bases: <code>ImageParserConfig</code></p> <p>Configuration for DLite image parser.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>class DLiteImageConfig(ImageParserConfig):\n    \"\"\"Configuration for DLite image parser.\"\"\"\n\n    image_label: Annotated[\n        str,\n        Field(\n            description=\"Label to assign to the image in the collection.\",\n        ),\n    ] = \"image\"\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageConfig.image_label","title":"<code>image_label: Annotated[str, Field(description='Label to assign to the image in the collection.')] = 'image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy","title":"<code>DLiteImageParseStrategy</code>","text":"<p>Parse strategy for image files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"image/vnd.dlite-gif\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jpeg\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jpg\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jp2\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-png\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-tiff\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>@dataclass\nclass DLiteImageParseStrategy:\n    \"\"\"Parse strategy for image files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"image/vnd.dlite-gif\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jpeg\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jpg\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jp2\")`\n    - `(\"mediaType\", \"image/vnd.dlite-png\")`\n    - `(\"mediaType\", \"image/vnd.dlite-tiff\")`\n\n    \"\"\"\n\n    parse_config: DLiteImageResourceConfig\n\n    def initialize(\n        self, session: \"Optional[dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific\n        endpoint of the OTE-API Services.  It assumes that the image to\n        parse is stored in a data cache, and can be retrieved via a key\n        that is supplied in either the session (highest priority)\n        or in the parser configuration (lowest priority).\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            DLite instance.\n        \"\"\"\n        config = self.parse_config.configuration\n\n        # Configuration for ImageDataParseStrategy in oteapi-core\n        conf = self.parse_config.model_dump()\n        conf[\"configuration\"] = ImageParserConfig(\n            **config.model_dump(), extra=\"ignore\"\n        )\n        conf[\"mediaType\"] = \"image/\" + conf[\"mediaType\"].split(\"-\")[-1]\n        core_config = ImageParserResourceConfig(**conf)\n\n        parse_strategy_session = ImageDataParseStrategy(core_config).initialize(\n            session\n        )\n        output = ImageDataParseStrategy(core_config).get(parse_strategy_session)\n\n        cache = DataCache()\n        data = cache.get(output[\"image_key\"])\n        if isinstance(data, bytes):\n            data = np.asarray(\n                Image.frombytes(\n                    data=data,\n                    mode=output[\"image_mode\"],\n                    size=output[\"image_size\"],\n                )\n            )\n        if not isinstance(data, np.ndarray):\n            raise TypeError(\n                \"Expected image data to be a numpy array, instead it was \"\n                f\"{type(data)}.\"\n            )\n\n        meta = get_meta(\"http://onto-ns.com/meta/1.0/Image\")\n        inst = meta(dimensions=data.shape)\n        inst[\"data\"] = data\n\n        LOGGER.info(\"session: %s\", session)\n\n        coll = get_collection(session)\n        coll.add(config.image_label, inst)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.parse_config","title":"<code>parse_config: DLiteImageResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.  It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority).</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>DLite instance.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>def get(\n    self, session: \"Optional[dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific\n    endpoint of the OTE-API Services.  It assumes that the image to\n    parse is stored in a data cache, and can be retrieved via a key\n    that is supplied in either the session (highest priority)\n    or in the parser configuration (lowest priority).\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        DLite instance.\n    \"\"\"\n    config = self.parse_config.configuration\n\n    # Configuration for ImageDataParseStrategy in oteapi-core\n    conf = self.parse_config.model_dump()\n    conf[\"configuration\"] = ImageParserConfig(\n        **config.model_dump(), extra=\"ignore\"\n    )\n    conf[\"mediaType\"] = \"image/\" + conf[\"mediaType\"].split(\"-\")[-1]\n    core_config = ImageParserResourceConfig(**conf)\n\n    parse_strategy_session = ImageDataParseStrategy(core_config).initialize(\n        session\n    )\n    output = ImageDataParseStrategy(core_config).get(parse_strategy_session)\n\n    cache = DataCache()\n    data = cache.get(output[\"image_key\"])\n    if isinstance(data, bytes):\n        data = np.asarray(\n            Image.frombytes(\n                data=data,\n                mode=output[\"image_mode\"],\n                size=output[\"image_size\"],\n            )\n        )\n    if not isinstance(data, np.ndarray):\n        raise TypeError(\n            \"Expected image data to be a numpy array, instead it was \"\n            f\"{type(data)}.\"\n        )\n\n    meta = get_meta(\"http://onto-ns.com/meta/1.0/Image\")\n    inst = meta(dimensions=data.shape)\n    inst[\"data\"] = data\n\n    LOGGER.info(\"session: %s\", session)\n\n    coll = get_collection(session)\n    coll.add(config.image_label, inst)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>def initialize(\n    self, session: \"Optional[dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageResourceConfig","title":"<code>DLiteImageResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>Resource config for DLite image parser.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>class DLiteImageResourceConfig(ResourceConfig):\n    \"\"\"Resource config for DLite image parser.\"\"\"\n\n    configuration: Annotated[\n        DLiteImageConfig,\n        Field(\n            description=\"Image parse strategy-specific configuration.\",\n        ),\n    ] = DLiteImageConfig()\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageResourceConfig.configuration","title":"<code>configuration: Annotated[DLiteImageConfig, Field(description='Image parse strategy-specific configuration.')] = DLiteImageConfig()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/serialise/","title":"serialise","text":"<p>Filter for serialisation using DLite.</p>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig","title":"<code>SerialiseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>DLite serialise-specific configurations.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>class SerialiseConfig(AttrDict):\n    \"\"\"DLite serialise-specific configurations.\"\"\"\n\n    driver: Annotated[\n        str,\n        Field(\n            description=\"Name of DLite plugin used for serialisation.\",\n        ),\n    ]\n    location: Annotated[\n        Path,\n        Field(\n            description=\"Path or URL to serialise to.\",\n        ),\n    ]\n    options: Annotated[\n        Optional[str],\n        Field(\n            description=\"Options passed to the driver.\",\n        ),\n    ] = \"\"\n    labels: Annotated[\n        Optional[Sequence[str]],\n        Field(\n            None,\n            description=(\n                \"Optional sequence of labels in the collection to serialise.  \"\n                \"The default is to serialise the entire collection.\"\n            ),\n        ),\n    ] = None\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig.driver","title":"<code>driver: Annotated[str, Field(description='Name of DLite plugin used for serialisation.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig.labels","title":"<code>labels: Annotated[Optional[Sequence[str]], Field(None, description='Optional sequence of labels in the collection to serialise.  The default is to serialise the entire collection.')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig.location","title":"<code>location: Annotated[Path, Field(description='Path or URL to serialise to.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig.options","title":"<code>options: Annotated[Optional[str], Field(description='Options passed to the driver.')] = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig","title":"<code>SerialiseFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>Filter config for serialise.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>class SerialiseFilterConfig(FilterConfig):\n    \"\"\"Filter config for serialise.\"\"\"\n\n    configuration: Annotated[\n        SerialiseConfig,\n        Field(\n            description=\"Serialise-specific configurations.\",\n        ),\n    ]\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig.configuration","title":"<code>configuration: Annotated[SerialiseConfig, Field(description='Serialise-specific configurations.')]</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy","title":"<code>SerialiseStrategy</code>","text":"<p>Filter for serialisation using DLite.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"dlite_serialise\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>@dataclass\nclass SerialiseStrategy:\n    \"\"\"Filter for serialisation using DLite.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"dlite_serialise\")`\n\n    \"\"\"\n\n    filter_config: SerialiseFilterConfig\n\n    def initialize(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: Optional[dict[str, \"Any\"]] = None\n    ) -&gt; DLiteSessionUpdate:\n        \"\"\"Execute the strategy.\"\"\"\n        config = self.filter_config.configuration\n\n        coll = get_collection(session)\n\n        storage = dlite.Storage(\n            driver_or_url=config.driver,\n            location=str(config.location),\n            options=config.options,\n        )\n        if config.labels is None:\n            coll.save_to_storage(storage)\n        else:\n            for label in config.labels:\n                inst = coll.get(label)\n                inst.save_to_storage(storage)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.filter_config","title":"<code>filter_config: SerialiseFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>def get(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Execute the strategy.\"\"\"\n    config = self.filter_config.configuration\n\n    coll = get_collection(session)\n\n    storage = dlite.Storage(\n        driver_or_url=config.driver,\n        location=str(config.location),\n        options=config.options,\n    )\n    if config.labels is None:\n        coll.save_to_storage(storage)\n    else:\n        for label in config.labels:\n            inst = coll.get(label)\n            inst.save_to_storage(storage)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>def initialize(\n    self, session: Optional[dict[str, \"Any\"]] = None\n) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/utils/exceptions/","title":"exceptions","text":"<p>OTEAPI-DLite exceptions.</p>"},{"location":"api_reference/utils/exceptions/#oteapi_dlite.utils.exceptions.CollectionNotFound","title":"<code>CollectionNotFound</code>","text":"<p>               Bases: <code>OteapiDliteException</code></p> <p>A dlite.Collection could not be found.</p> Source code in <code>oteapi_dlite/utils/exceptions.py</code> <pre><code>class CollectionNotFound(OteapiDliteException):\n    \"\"\"A dlite.Collection could not be found.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#oteapi_dlite.utils.exceptions.OteapiDliteException","title":"<code>OteapiDliteException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>A catch-em-all generic OTEAPI-DLite exception.</p> Source code in <code>oteapi_dlite/utils/exceptions.py</code> <pre><code>class OteapiDliteException(Exception):\n    \"\"\"A catch-em-all generic OTEAPI-DLite exception.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/nputils/","title":"nputils","text":"<p>NumNy-related utility functions.</p>"},{"location":"api_reference/utils/nputils/#oteapi_dlite.utils.nputils.dict2recarray","title":"<code>dict2recarray(excel_dict, names=None)</code>","text":"<p>Converts a dict returned by the Excel parser to a numpy rec array.</p> <p>If <code>names</code> is None, the record names are inferred from <code>excel_dict</code>.</p> Source code in <code>oteapi_dlite/utils/nputils.py</code> <pre><code>def dict2recarray(\n    excel_dict: dict[str, \"Any\"], names: \"Optional[Sequence[str]]\" = None\n) -&gt; np.recarray:\n    \"\"\"Converts a dict returned by the Excel parser to a numpy rec array.\n\n    If `names` is None, the record names are inferred from `excel_dict`.\n    \"\"\"\n    arrays = []\n    for arr in excel_dict.values():\n        if all(\n            isinstance(v, (bool, int, float, complex, None.__class__))\n            for v in arr\n        ):\n            arrays.append([np.nan if v is None else v for v in arr])\n        elif all(isinstance(v, (str, bytes, None.__class__)) for v in arr):\n            arrays.append([\"\" if v is None else v for v in arr])\n        else:\n            arrays.append(arr)\n        if names is None:\n            names = list(excel_dict.keys())\n    return np.rec.fromarrays(arrays, names=names)\n</code></pre>"},{"location":"api_reference/utils/utils/","title":"utils","text":"<p>Utility functions for OTEAPI DLite plugin.</p>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_collection","title":"<code>get_collection(session=None, collection_id=None)</code>","text":"<p>Retrieve a DLite Collection.</p> <p>Looks for a Collection UUID in the session. If none exists, a new, empty Collection is created and stored in the session.</p> <p>If <code>collection_id</code> is provided, that id is used. If there already is a <code>collection_id</code> in the session, that is left untouched. Otherwise <code>collection_id</code> is added to the session.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[dict[str, Any]]</code> <p>An OTEAPI session object.</p> <code>None</code> <code>collection_id</code> <code>Optional[str]</code> <p>A specific collection ID to retrieve.</p> <code>None</code> Return <p>A DLite Collection to be used throughout the OTEAPI session.</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_collection(\n    session: \"Optional[dict[str, Any]]\" = None,\n    collection_id: \"Optional[str]\" = None,\n) -&gt; dlite.Collection:\n    \"\"\"Retrieve a DLite Collection.\n\n    Looks for a Collection UUID in the session.\n    If none exists, a new, empty Collection is created and stored in the\n    session.\n\n    If `collection_id` is provided, that id is used. If there already is a\n    `collection_id` in the session, that is left untouched. Otherwise\n    `collection_id` is added to the session.\n\n    Parameters:\n        session: An OTEAPI session object.\n        collection_id: A specific collection ID to retrieve.\n\n    Return:\n        A DLite Collection to be used throughout the OTEAPI session.\n    \"\"\"\n    cache = DataCache()\n\n    session = session or {}\n    id_ = collection_id or session.get(\"collection_id\")\n\n    # Storing the collection in the datacache is not scalable.\n    # Do we really want to do that?\n    #\n    # Currently we check the datacache first and then ask dlite to look\n    # up the collection (which is the proper and scalable solution).\n    if id_ is None:\n        coll = dlite.Collection()\n        cache.add(coll.asjson(), key=coll.uuid)\n    elif id_ in cache:\n        coll = dlite.Instance.from_json(cache.get(id_), id=id_)\n    else:\n        try:\n            coll = dlite.get_instance(id_)\n        except dlite.DLiteError as exc:  # pylint: disable=no-member\n            raise CollectionNotFound(\n                f\"Could not find DLite Collection with id {id_}\"\n            ) from exc\n\n    if coll.meta.uri != dlite.COLLECTION_ENTITY:\n        raise CollectionNotFound(f\"instance with id {id_} is not a collection\")\n\n    if \"collection_id\" not in session:\n        session[\"collection_id\"] = coll.uuid\n\n    return coll\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_driver","title":"<code>get_driver(mediaType=None, accessService=None, options=None)</code>","text":"<p>Return name of DLite driver for the given media type/access service.</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_driver(\n    mediaType: \"Optional[str]\" = None,\n    accessService: \"Optional[str]\" = None,\n    options: \"NoneType\" = None,\n) -&gt; str:\n    \"\"\"Return name of DLite driver for the given media type/access service.\"\"\"\n    # pylint: disable=unused-argument\n    if mediaType:\n        if mediaType not in MEDIATYPES:\n            raise ValueError(\"unknown DLite mediaType: {mediaType}\")\n        return MEDIATYPES[mediaType]\n\n    if accessService:\n        if accessService not in ACCESSSERVICES:\n            raise ValueError(\"unknown DLite accessService: {accessService}\")\n        return ACCESSSERVICES[accessService]\n\n    raise ValueError(\"either `mediaType` or `accessService` must be provided\")\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_instance","title":"<code>get_instance(meta, collection, routedict=None, instance_id=None, allow_incomplete=False, **kwargs)</code>","text":"<p>Instantiates and returns an instance of <code>meta</code>.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>Union[str, Metadata]</code> <p>Metadata to instantiate.  Typically its URI.</p> required <code>collection</code> <code>Collection</code> <p>The collection with instances and mappings.</p> required Some less used optional arguments <p>routedict: Dict mapping property names to route number to select for     the given property.  The default is to select the route with     lowest cost. instance_id: URI of instance to create. allow_incomplete: Whether to allow not populating all properties     of the returned instance. kwargs: Additional arguments passed to dlite.mappings.instantiate().</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_instance(\n    meta: \"Union[str, dlite.Metadata]\",\n    collection: dlite.Collection,\n    routedict: \"Optional[dict]\" = None,\n    instance_id: \"Optional[str]\" = None,\n    allow_incomplete: bool = False,\n    **kwargs,\n) -&gt; dlite.Instance:\n    \"\"\"Instantiates and returns an instance of `meta`.\n\n    Arguments:\n        meta: Metadata to instantiate.  Typically its URI.\n        collection: The collection with instances and mappings.\n\n    Some less used optional arguments:\n        routedict: Dict mapping property names to route number to select for\n            the given property.  The default is to select the route with\n            lowest cost.\n        instance_id: URI of instance to create.\n        allow_incomplete: Whether to allow not populating all properties\n            of the returned instance.\n        kwargs: Additional arguments passed to dlite.mappings.instantiate().\n    \"\"\"\n    ts = Triplestore(backend=\"collection\", collection=collection)\n    inst = instantiate(\n        meta=meta,\n        instances=list(collection.get_instances()),\n        triplestore=ts,\n        routedict=routedict,\n        id=instance_id,\n        allow_incomplete=allow_incomplete,\n        **kwargs,\n    )\n    return inst\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_meta","title":"<code>get_meta(uri)</code>","text":"<p>Returns metadata corresponding to given uri.</p> <p>This function may in the future be connected to a database.</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_meta(uri: str) -&gt; dlite.Instance:\n    \"\"\"Returns metadata corresponding to given uri.\n\n    This function may in the future be connected to a database.\n    \"\"\"\n    meta = dlite.get_instance(uri)\n    if not meta.is_meta:\n        raise ValueError(\"uri {uri} does not correspond to metadata\")\n    return meta\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.update_collection","title":"<code>update_collection(collection)</code>","text":"<p>Update collection in DataCache.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Collection</code> <p>The DLite Collection to be updated.</p> required Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def update_collection(collection: dlite.Collection) -&gt; None:\n    \"\"\"Update collection in DataCache.\n\n    Parameters:\n        collection: The DLite Collection to be updated.\n    \"\"\"\n    cache = DataCache()\n    cache.add(value=collection.asjson(), key=collection.uuid)\n</code></pre>"}]}