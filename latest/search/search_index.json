{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OTEAPI DLite Plugin \u00b6 All strategies implemented in this plugin (except for create_collection ) assumes that you have the UUID of a DLite collection with the key collection_id in the session : collection_id = session [ \"collection_id\" ] coll = dlite . get_collection ( collection_id ) A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case. In order to make it easy retrieve the collection id when executing a pipeline, the get() method of all filters in this plugin should return the collection_id . Further reading: OTE-API Core Documentation OTE-API Services Documentation DLite License and copyright \u00b6 The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF. Acknowledgment \u00b6 OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins . OTEAPI DLite Plugin has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Home"},{"location":"#oteapi-dlite-plugin","text":"All strategies implemented in this plugin (except for create_collection ) assumes that you have the UUID of a DLite collection with the key collection_id in the session : collection_id = session [ \"collection_id\" ] coll = dlite . get_collection ( collection_id ) A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case. In order to make it easy retrieve the collection id when executing a pipeline, the get() method of all filters in this plugin should return the collection_id . Further reading: OTE-API Core Documentation OTE-API Services Documentation DLite","title":"OTEAPI DLite Plugin"},{"location":"#license-and-copyright","text":"The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF.","title":"License and copyright"},{"location":"#acknowledgment","text":"OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins . OTEAPI DLite Plugin has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Acknowledgment"},{"location":"CHANGELOG/","text":"Changelog \u00b6 This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"all_strategies/","text":"OTEAPI DLite Plugin Strategies \u00b6 This page provides documentation for the oteapi_dlite.strategies submodule, where all the OTEAPI DLite Plugin strategies are located. These strategies will be available when setting up a server in an environment with oteapi-dlite installed. filter \u00b6 Trivial filter that adds an empty collection to the session. CreateCollectionStrategy \u00b6 Trivial filter that adds an empty collection to the session. Registers strategies : (\"filterType\", \"create_collection\") Source code in oteapi_dlite/strategies/filter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @dataclass class CreateCollectionStrategy : \"\"\"Trivial filter that adds an empty collection to the session. **Registers strategies**: - `(\"filterType\", \"create_collection\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi_dlite/strategies/filter.py 44 45 46 47 48 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/filter.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid ) parse_excel \u00b6 Strategy for parsing an Excel spreadsheet to a DLite instance. DLiteExcelParseConfig \u00b6 Bases: AttrDict Configuration for DLite Excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DLiteExcelParseConfig ( AttrDict ): \"\"\"Configuration for DLite Excel parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) excel_config : XLSXParseConfig = Field ( ... , description = \"DLite-specific excel configurations.\" , ) DLiteExcelParseResourceConfig \u00b6 Bases: ResourceConfig DLite excel parse strategy resource config. Source code in oteapi_dlite/strategies/parse_excel.py 48 49 50 51 52 53 class DLiteExcelParseResourceConfig ( ResourceConfig ): \"\"\"DLite excel parse strategy resource config.\"\"\" configuration : DLiteExcelParseConfig = Field ( ... , description = \"DLite excel parse strategy-specific configuration.\" ) DLiteExcelSessionUpdate \u00b6 Bases: DLiteSessionUpdate Class for returning values from DLite excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 56 57 58 59 60 61 62 63 64 65 66 class DLiteExcelSessionUpdate ( DLiteSessionUpdate ): \"\"\"Class for returning values from DLite excel parser.\"\"\" inst_uuid : str = Field ( ... , description = \"UUID of new instance.\" , ) label : str = Field ( ... , description = \"Label of the new instance in the collection.\" , ) DLiteExcelStrategy \u00b6 Parse strategy for Excel files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse_excel.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @dataclass class DLiteExcelStrategy : \"\"\"Parse strategy for Excel files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_excel.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse_excel.py 81 82 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) infer_metadata ( rec , units ) \u00b6 Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse_excel.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def infer_metadata ( rec : np . recarray , units : list ) -> dlite . Instance : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_excel_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from excel file.\" , ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get () split_column_name ( column ) \u00b6 Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse_excel.py 137 138 139 140 141 142 143 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit parse_image \u00b6 Strategy class for parsing an image to a DLite instance. DLiteImageConfig \u00b6 Bases: BaseModel Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 24 25 26 27 28 29 30 31 32 33 class DLiteImageConfig ( BaseModel ): \"\"\"Configuration for DLite image parser.\"\"\" crop : Optional [ Tuple ] = Field ( None , description = \"Cropping rectangle. The whole image if None.\" ) image_label : str = Field ( \"image\" , description = \"Label to assign to the image in the collection.\" , ) DLiteImageParseStrategy \u00b6 Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/tiff\") Source code in oteapi_dlite/strategies/parse_image.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/tiff\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session 'Dict[str, Any]' A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse_image.py 53 54 55 56 57 def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) serialise \u00b6 Filter for serialisation using DLite. SerialiseConfig \u00b6 Bases: AttrDict DLite serialise-specific configurations. Source code in oteapi_dlite/strategies/serialise.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SerialiseConfig ( AttrDict ): \"\"\"DLite serialise-specific configurations.\"\"\" driver : str = Field ( ... , description = \"Name of DLite plugin used for serialisation.\" , ) location : Path = Field ( ... , description = \"Path or URL to serialise to.\" , ) options : Optional [ str ] = Field ( \"\" , description = \"Options passed to the driver.\" , ) labels : Optional [ Sequence [ str ]] = Field ( None , description = ( \"Optional sequence of labels in the collection to serialise. \" \"The default is to serialise the entire collection.\" ), ) SerialiseFilterConfig \u00b6 Bases: FilterConfig Filter config for serialise. Source code in oteapi_dlite/strategies/serialise.py 41 42 43 44 45 46 47 class SerialiseFilterConfig ( FilterConfig ): \"\"\"Filter config for serialise.\"\"\" configuration : SerialiseConfig = Field ( ... , description = \"Serialise-specific configurations.\" , ) SerialiseStrategy \u00b6 Filter for serialisation using DLite. Registers strategies : (\"filterType\", \"dlite_serialise\") Source code in oteapi_dlite/strategies/serialise.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @dataclass class SerialiseStrategy : \"\"\"Filter for serialisation using DLite. **Registers strategies**: - `(\"filterType\", \"dlite_serialise\")` \"\"\" filter_config : \"SerialiseFilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi_dlite/strategies/serialise.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/serialise.py 62 63 64 65 66 67 68 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"OTEAPI DLite Plugin Strategies"},{"location":"all_strategies/#oteapi-dlite-plugin-strategies","text":"This page provides documentation for the oteapi_dlite.strategies submodule, where all the OTEAPI DLite Plugin strategies are located. These strategies will be available when setting up a server in an environment with oteapi-dlite installed.","title":"OTEAPI DLite Plugin Strategies"},{"location":"all_strategies/#oteapi_dlite.strategies.filter","text":"Trivial filter that adds an empty collection to the session.","title":"filter"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.CreateCollectionStrategy","text":"Trivial filter that adds an empty collection to the session. Registers strategies : (\"filterType\", \"create_collection\") Source code in oteapi_dlite/strategies/filter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @dataclass class CreateCollectionStrategy : \"\"\"Trivial filter that adds an empty collection to the session. **Registers strategies**: - `(\"filterType\", \"create_collection\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"CreateCollectionStrategy"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.get","text":"Execute the strategy. Source code in oteapi_dlite/strategies/filter.py 44 45 46 47 48 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"get()"},{"location":"all_strategies/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/filter.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"initialize()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel","text":"Strategy for parsing an Excel spreadsheet to a DLite instance.","title":"parse_excel"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig","text":"Bases: AttrDict Configuration for DLite Excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DLiteExcelParseConfig ( AttrDict ): \"\"\"Configuration for DLite Excel parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) excel_config : XLSXParseConfig = Field ( ... , description = \"DLite-specific excel configurations.\" , )","title":"DLiteExcelParseConfig"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig","text":"Bases: ResourceConfig DLite excel parse strategy resource config. Source code in oteapi_dlite/strategies/parse_excel.py 48 49 50 51 52 53 class DLiteExcelParseResourceConfig ( ResourceConfig ): \"\"\"DLite excel parse strategy resource config.\"\"\" configuration : DLiteExcelParseConfig = Field ( ... , description = \"DLite excel parse strategy-specific configuration.\" )","title":"DLiteExcelParseResourceConfig"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate","text":"Bases: DLiteSessionUpdate Class for returning values from DLite excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 56 57 58 59 60 61 62 63 64 65 66 class DLiteExcelSessionUpdate ( DLiteSessionUpdate ): \"\"\"Class for returning values from DLite excel parser.\"\"\" inst_uuid : str = Field ( ... , description = \"UUID of new instance.\" , ) label : str = Field ( ... , description = \"Label of the new instance in the collection.\" , )","title":"DLiteExcelSessionUpdate"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy","text":"Parse strategy for Excel files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse_excel.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @dataclass class DLiteExcelStrategy : \"\"\"Parse strategy for Excel files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , )","title":"DLiteExcelStrategy"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_excel.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , )","title":"get()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse_excel.py 81 82 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.infer_metadata","text":"Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse_excel.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def infer_metadata ( rec : np . recarray , units : list ) -> dlite . Instance : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_excel_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from excel file.\" , ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get ()","title":"infer_metadata()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_excel.split_column_name","text":"Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse_excel.py 137 138 139 140 141 142 143 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"split_column_name()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image","text":"Strategy class for parsing an image to a DLite instance.","title":"parse_image"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageConfig","text":"Bases: BaseModel Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 24 25 26 27 28 29 30 31 32 33 class DLiteImageConfig ( BaseModel ): \"\"\"Configuration for DLite image parser.\"\"\" crop : Optional [ Tuple ] = Field ( None , description = \"Cropping rectangle. The whole image if None.\" ) image_label : str = Field ( \"image\" , description = \"Label to assign to the image in the collection.\" , )","title":"DLiteImageConfig"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy","text":"Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/tiff\") Source code in oteapi_dlite/strategies/parse_image.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/tiff\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"DLiteImageParseStrategy"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session 'Dict[str, Any]' A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"get()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse_image.py 53 54 55 56 57 def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise","text":"Filter for serialisation using DLite.","title":"serialise"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseConfig","text":"Bases: AttrDict DLite serialise-specific configurations. Source code in oteapi_dlite/strategies/serialise.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SerialiseConfig ( AttrDict ): \"\"\"DLite serialise-specific configurations.\"\"\" driver : str = Field ( ... , description = \"Name of DLite plugin used for serialisation.\" , ) location : Path = Field ( ... , description = \"Path or URL to serialise to.\" , ) options : Optional [ str ] = Field ( \"\" , description = \"Options passed to the driver.\" , ) labels : Optional [ Sequence [ str ]] = Field ( None , description = ( \"Optional sequence of labels in the collection to serialise. \" \"The default is to serialise the entire collection.\" ), )","title":"SerialiseConfig"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig","text":"Bases: FilterConfig Filter config for serialise. Source code in oteapi_dlite/strategies/serialise.py 41 42 43 44 45 46 47 class SerialiseFilterConfig ( FilterConfig ): \"\"\"Filter config for serialise.\"\"\" configuration : SerialiseConfig = Field ( ... , description = \"Serialise-specific configurations.\" , )","title":"SerialiseFilterConfig"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseStrategy","text":"Filter for serialisation using DLite. Registers strategies : (\"filterType\", \"dlite_serialise\") Source code in oteapi_dlite/strategies/serialise.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @dataclass class SerialiseStrategy : \"\"\"Filter for serialisation using DLite. **Registers strategies**: - `(\"filterType\", \"dlite_serialise\")` \"\"\" filter_config : \"SerialiseFilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"SerialiseStrategy"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseStrategy.get","text":"Execute the strategy. Source code in oteapi_dlite/strategies/serialise.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"get()"},{"location":"all_strategies/#oteapi_dlite.strategies.serialise.SerialiseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/serialise.py 62 63 64 65 66 67 68 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"api_reference/models/session/","text":"session \u00b6 Pydantic data models for DLite. DLiteSessionUpdate \u00b6 Bases: SessionUpdate Class for returning values from DLite strategies. Source code in oteapi_dlite/models/session.py 24 25 26 27 28 29 30 class DLiteSessionUpdate ( SessionUpdate ): \"\"\"Class for returning values from DLite strategies.\"\"\" collection_id : Optional [ str ] = Field ( {}, # default_factory=new_collection, description = \"A reference to a DLite collection.\" , ) collection_id : Optional [ str ] = Field ({}, description = 'A reference to a DLite collection.' ) class-attribute \u00b6","title":"session"},{"location":"api_reference/models/session/#session","text":"Pydantic data models for DLite.","title":"session"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate","text":"Bases: SessionUpdate Class for returning values from DLite strategies. Source code in oteapi_dlite/models/session.py 24 25 26 27 28 29 30 class DLiteSessionUpdate ( SessionUpdate ): \"\"\"Class for returning values from DLite strategies.\"\"\" collection_id : Optional [ str ] = Field ( {}, # default_factory=new_collection, description = \"A reference to a DLite collection.\" , )","title":"DLiteSessionUpdate"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate.collection_id","text":"","title":"collection_id"},{"location":"api_reference/strategies/filter/","text":"filter \u00b6 Trivial filter that adds an empty collection to the session. CreateCollectionStrategy \u00b6 Trivial filter that adds an empty collection to the session. Registers strategies : (\"filterType\", \"create_collection\") Source code in oteapi_dlite/strategies/filter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @dataclass class CreateCollectionStrategy : \"\"\"Trivial filter that adds an empty collection to the session. **Registers strategies**: - `(\"filterType\", \"create_collection\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi_dlite/strategies/filter.py 44 45 46 47 48 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/filter.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"filter"},{"location":"api_reference/strategies/filter/#filter","text":"Trivial filter that adds an empty collection to the session.","title":"filter"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy","text":"Trivial filter that adds an empty collection to the session. Registers strategies : (\"filterType\", \"create_collection\") Source code in oteapi_dlite/strategies/filter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @dataclass class CreateCollectionStrategy : \"\"\"Trivial filter that adds an empty collection to the session. **Registers strategies**: - `(\"filterType\", \"create_collection\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"CreateCollectionStrategy"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.get","text":"Execute the strategy. Source code in oteapi_dlite/strategies/filter.py 44 45 46 47 48 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"get()"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/filter.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Save reference to the collection to ensure that it lives as long as # the session does session [ \"_collection_ref\" ] = coll return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"initialize()"},{"location":"api_reference/strategies/parse_excel/","text":"parse_excel \u00b6 Strategy for parsing an Excel spreadsheet to a DLite instance. DLiteExcelParseConfig \u00b6 Bases: AttrDict Configuration for DLite Excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DLiteExcelParseConfig ( AttrDict ): \"\"\"Configuration for DLite Excel parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) excel_config : XLSXParseConfig = Field ( ... , description = \"DLite-specific excel configurations.\" , ) DLiteExcelParseResourceConfig \u00b6 Bases: ResourceConfig DLite excel parse strategy resource config. Source code in oteapi_dlite/strategies/parse_excel.py 48 49 50 51 52 53 class DLiteExcelParseResourceConfig ( ResourceConfig ): \"\"\"DLite excel parse strategy resource config.\"\"\" configuration : DLiteExcelParseConfig = Field ( ... , description = \"DLite excel parse strategy-specific configuration.\" ) DLiteExcelSessionUpdate \u00b6 Bases: DLiteSessionUpdate Class for returning values from DLite excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 56 57 58 59 60 61 62 63 64 65 66 class DLiteExcelSessionUpdate ( DLiteSessionUpdate ): \"\"\"Class for returning values from DLite excel parser.\"\"\" inst_uuid : str = Field ( ... , description = \"UUID of new instance.\" , ) label : str = Field ( ... , description = \"Label of the new instance in the collection.\" , ) DLiteExcelStrategy \u00b6 Parse strategy for Excel files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse_excel.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @dataclass class DLiteExcelStrategy : \"\"\"Parse strategy for Excel files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_excel.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse_excel.py 81 82 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) infer_metadata ( rec , units ) \u00b6 Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse_excel.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def infer_metadata ( rec : np . recarray , units : list ) -> dlite . Instance : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_excel_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from excel file.\" , ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get () split_column_name ( column ) \u00b6 Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse_excel.py 137 138 139 140 141 142 143 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"parse_excel"},{"location":"api_reference/strategies/parse_excel/#parse_excel","text":"Strategy for parsing an Excel spreadsheet to a DLite instance.","title":"parse_excel"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig","text":"Bases: AttrDict Configuration for DLite Excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DLiteExcelParseConfig ( AttrDict ): \"\"\"Configuration for DLite Excel parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) excel_config : XLSXParseConfig = Field ( ... , description = \"DLite-specific excel configurations.\" , )","title":"DLiteExcelParseConfig"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig","text":"Bases: ResourceConfig DLite excel parse strategy resource config. Source code in oteapi_dlite/strategies/parse_excel.py 48 49 50 51 52 53 class DLiteExcelParseResourceConfig ( ResourceConfig ): \"\"\"DLite excel parse strategy resource config.\"\"\" configuration : DLiteExcelParseConfig = Field ( ... , description = \"DLite excel parse strategy-specific configuration.\" )","title":"DLiteExcelParseResourceConfig"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate","text":"Bases: DLiteSessionUpdate Class for returning values from DLite excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 56 57 58 59 60 61 62 63 64 65 66 class DLiteExcelSessionUpdate ( DLiteSessionUpdate ): \"\"\"Class for returning values from DLite excel parser.\"\"\" inst_uuid : str = Field ( ... , description = \"UUID of new instance.\" , ) label : str = Field ( ... , description = \"Label of the new instance in the collection.\" , )","title":"DLiteExcelSessionUpdate"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy","text":"Parse strategy for Excel files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse_excel.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @dataclass class DLiteExcelStrategy : \"\"\"Parse strategy for Excel files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , )","title":"DLiteExcelStrategy"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_excel.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteExcelParseConfig ( ** self . parse_config . configuration ) xlsx_session = self . parse_config . copy () xlsx_session . configuration = config . excel_config parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_session ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : raise NotImplementedError ( \"\" ) # else meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , )","title":"get()"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse_excel.py 81 82 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.infer_metadata","text":"Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse_excel.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def infer_metadata ( rec : np . recarray , units : list ) -> dlite . Instance : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_excel_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from excel file.\" , ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get ()","title":"infer_metadata()"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.split_column_name","text":"Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse_excel.py 137 138 139 140 141 142 143 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"split_column_name()"},{"location":"api_reference/strategies/parse_image/","text":"parse_image \u00b6 Strategy class for parsing an image to a DLite instance. DLiteImageConfig \u00b6 Bases: BaseModel Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 24 25 26 27 28 29 30 31 32 33 class DLiteImageConfig ( BaseModel ): \"\"\"Configuration for DLite image parser.\"\"\" crop : Optional [ Tuple ] = Field ( None , description = \"Cropping rectangle. The whole image if None.\" ) image_label : str = Field ( \"image\" , description = \"Label to assign to the image in the collection.\" , ) DLiteImageParseStrategy \u00b6 Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/tiff\") Source code in oteapi_dlite/strategies/parse_image.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/tiff\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session 'Dict[str, Any]' A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse_image.py 53 54 55 56 57 def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"parse_image"},{"location":"api_reference/strategies/parse_image/#parse_image","text":"Strategy class for parsing an image to a DLite instance.","title":"parse_image"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageConfig","text":"Bases: BaseModel Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 24 25 26 27 28 29 30 31 32 33 class DLiteImageConfig ( BaseModel ): \"\"\"Configuration for DLite image parser.\"\"\" crop : Optional [ Tuple ] = Field ( None , description = \"Cropping rectangle. The whole image if None.\" ) image_label : str = Field ( \"image\" , description = \"Label to assign to the image in the collection.\" , )","title":"DLiteImageConfig"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy","text":"Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/tiff\") Source code in oteapi_dlite/strategies/parse_image.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/tiff\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"DLiteImageParseStrategy"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session 'Dict[str, Any]' A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())]) inst [ \"data\" ] = data coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( image_config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"get()"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse_image.py 53 54 55 56 57 def initialize ( self , session : \"Dict[str, Any]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"api_reference/strategies/serialise/","text":"serialise \u00b6 Filter for serialisation using DLite. SerialiseConfig \u00b6 Bases: AttrDict DLite serialise-specific configurations. Source code in oteapi_dlite/strategies/serialise.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SerialiseConfig ( AttrDict ): \"\"\"DLite serialise-specific configurations.\"\"\" driver : str = Field ( ... , description = \"Name of DLite plugin used for serialisation.\" , ) location : Path = Field ( ... , description = \"Path or URL to serialise to.\" , ) options : Optional [ str ] = Field ( \"\" , description = \"Options passed to the driver.\" , ) labels : Optional [ Sequence [ str ]] = Field ( None , description = ( \"Optional sequence of labels in the collection to serialise. \" \"The default is to serialise the entire collection.\" ), ) SerialiseFilterConfig \u00b6 Bases: FilterConfig Filter config for serialise. Source code in oteapi_dlite/strategies/serialise.py 41 42 43 44 45 46 47 class SerialiseFilterConfig ( FilterConfig ): \"\"\"Filter config for serialise.\"\"\" configuration : SerialiseConfig = Field ( ... , description = \"Serialise-specific configurations.\" , ) SerialiseStrategy \u00b6 Filter for serialisation using DLite. Registers strategies : (\"filterType\", \"dlite_serialise\") Source code in oteapi_dlite/strategies/serialise.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @dataclass class SerialiseStrategy : \"\"\"Filter for serialisation using DLite. **Registers strategies**: - `(\"filterType\", \"dlite_serialise\")` \"\"\" filter_config : \"SerialiseFilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi_dlite/strategies/serialise.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/serialise.py 62 63 64 65 66 67 68 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"serialise"},{"location":"api_reference/strategies/serialise/#serialise","text":"Filter for serialisation using DLite.","title":"serialise"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig","text":"Bases: AttrDict DLite serialise-specific configurations. Source code in oteapi_dlite/strategies/serialise.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SerialiseConfig ( AttrDict ): \"\"\"DLite serialise-specific configurations.\"\"\" driver : str = Field ( ... , description = \"Name of DLite plugin used for serialisation.\" , ) location : Path = Field ( ... , description = \"Path or URL to serialise to.\" , ) options : Optional [ str ] = Field ( \"\" , description = \"Options passed to the driver.\" , ) labels : Optional [ Sequence [ str ]] = Field ( None , description = ( \"Optional sequence of labels in the collection to serialise. \" \"The default is to serialise the entire collection.\" ), )","title":"SerialiseConfig"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig","text":"Bases: FilterConfig Filter config for serialise. Source code in oteapi_dlite/strategies/serialise.py 41 42 43 44 45 46 47 class SerialiseFilterConfig ( FilterConfig ): \"\"\"Filter config for serialise.\"\"\" configuration : SerialiseConfig = Field ( ... , description = \"Serialise-specific configurations.\" , )","title":"SerialiseFilterConfig"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy","text":"Filter for serialisation using DLite. Registers strategies : (\"filterType\", \"dlite_serialise\") Source code in oteapi_dlite/strategies/serialise.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @dataclass class SerialiseStrategy : \"\"\"Filter for serialisation using DLite. **Registers strategies**: - `(\"filterType\", \"dlite_serialise\")` \"\"\" filter_config : \"SerialiseFilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"SerialiseStrategy"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.get","text":"Execute the strategy. Source code in oteapi_dlite/strategies/serialise.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"get()"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/serialise.py 62 63 64 65 66 67 68 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"api_reference/utils/nputils/","text":"nputils \u00b6 NumNy-related utility functions. dict2recarray ( excel_dict , names = None ) \u00b6 Converts a dict returned by the Excel parser to a numpy rec array. If names is None, the record names are inferred from excel_dict . Source code in oteapi_dlite/utils/nputils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def dict2recarray ( excel_dict , names = None ): \"\"\"Converts a dict returned by the Excel parser to a numpy rec array. If `names` is None, the record names are inferred from `excel_dict`. \"\"\" arrays = [] for arr in excel_dict . values (): if all ( isinstance ( v , ( bool , int , float , complex , None . __class__ )) for v in arr ): arrays . append ([ np . nan if v is None else v for v in arr ]) elif all ( isinstance ( v , ( str , bytes , None . __class__ )) for v in arr ): arrays . append ([ \"\" if v is None else v for v in arr ]) else : arrays . append ( arr ) if names is None : names = list ( excel_dict . keys ()) return np . rec . fromarrays ( arrays , names = names )","title":"nputils"},{"location":"api_reference/utils/nputils/#nputils","text":"NumNy-related utility functions.","title":"nputils"},{"location":"api_reference/utils/nputils/#oteapi_dlite.utils.nputils.dict2recarray","text":"Converts a dict returned by the Excel parser to a numpy rec array. If names is None, the record names are inferred from excel_dict . Source code in oteapi_dlite/utils/nputils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def dict2recarray ( excel_dict , names = None ): \"\"\"Converts a dict returned by the Excel parser to a numpy rec array. If `names` is None, the record names are inferred from `excel_dict`. \"\"\" arrays = [] for arr in excel_dict . values (): if all ( isinstance ( v , ( bool , int , float , complex , None . __class__ )) for v in arr ): arrays . append ([ np . nan if v is None else v for v in arr ]) elif all ( isinstance ( v , ( str , bytes , None . __class__ )) for v in arr ): arrays . append ([ \"\" if v is None else v for v in arr ]) else : arrays . append ( arr ) if names is None : names = list ( excel_dict . keys ()) return np . rec . fromarrays ( arrays , names = names )","title":"dict2recarray()"},{"location":"api_reference/utils/utils/","text":"utils \u00b6 Utility functions for OTEAPI DLite plugin. get_meta ( uri ) \u00b6 Returns metadata corresponding to given uri. This function may in the future be connected to a database. Source code in oteapi_dlite/utils/utils.py 11 12 13 14 15 16 17 18 19 def get_meta ( uri : str ) -> dlite . Instance : \"\"\"Returns metadata corresponding to given uri. This function may in the future be connected to a database. \"\"\" meta = dlite . get_instance ( uri ) if not meta . is_meta : raise ValueError ( \"uri {uri} does not correspond to metadata\" ) return meta","title":"utils"},{"location":"api_reference/utils/utils/#utils","text":"Utility functions for OTEAPI DLite plugin.","title":"utils"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_meta","text":"Returns metadata corresponding to given uri. This function may in the future be connected to a database. Source code in oteapi_dlite/utils/utils.py 11 12 13 14 15 16 17 18 19 def get_meta ( uri : str ) -> dlite . Instance : \"\"\"Returns metadata corresponding to given uri. This function may in the future be connected to a database. \"\"\" meta = dlite . get_instance ( uri ) if not meta . is_meta : raise ValueError ( \"uri {uri} does not correspond to metadata\" ) return meta","title":"get_meta()"}]}