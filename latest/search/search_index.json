{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OTEAPI DLite Plugin \u00b6 All strategies implemented in this plugin (except for create_collection ) assumes that you have the UUID of a DLite collection with the key collection_id in the session : collection_id = session [ \"collection_id\" ] coll = dlite . get_collection ( collection_id ) A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case. In order to make it easy retrieve the collection id when executing a pipeline, the get() method of all filters in this plugin should return the collection_id . Further reading: OTE-API Core Documentation OTE-API Services Documentation DLite License and copyright \u00b6 The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF. Acknowledgment \u00b6 OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins . OTEAPI DLite Plugin has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Home"},{"location":"#oteapi-dlite-plugin","text":"All strategies implemented in this plugin (except for create_collection ) assumes that you have the UUID of a DLite collection with the key collection_id in the session : collection_id = session [ \"collection_id\" ] coll = dlite . get_collection ( collection_id ) A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case. In order to make it easy retrieve the collection id when executing a pipeline, the get() method of all filters in this plugin should return the collection_id . Further reading: OTE-API Core Documentation OTE-API Services Documentation DLite","title":"OTEAPI DLite Plugin"},{"location":"#license-and-copyright","text":"The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF.","title":"License and copyright"},{"location":"#acknowledgment","text":"OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins . OTEAPI DLite Plugin has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Acknowledgment"},{"location":"CHANGELOG/","text":"Changelog \u00b6 This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"all_strategies/","text":"OTEAPI DLite Plugin Strategies \u00b6 This page provides documentation for the oteapi_dlite.strategies submodule, where all the OTEAPI DLite Plugin strategies are located. These strategies will be available when setting up a server in an environment with oteapi-dlite installed. parse \u00b6 Strategy class for parsing Excel XLSX to a DLite instance. DLiteXLSXConfig \u00b6 Bases: BaseModel Configuration for DLite XLSX parser. Source code in oteapi_dlite/strategies/parse.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class DLiteXLSXConfig ( BaseModel ): \"\"\"Configuration for DLite XLSX parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) xlsx_config : XLSXParseDataModel = Field ( ... , description = \"Excel XLSX configurations.\" , ) DLiteXLSXStrategy \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @dataclass class DLiteXLSXStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , ) get ( self , session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'Dict[str, Any]' DLite instance. Source code in oteapi_dlite/strategies/parse.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse.py 59 60 61 62 63 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate () infer_metadata ( rec , units ) \u00b6 Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse.py 124 125 126 127 128 129 130 131 132 133 134 def infer_metadata ( rec : np . recarray , units : list ) -> \"dlite.Instance\" : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_xlsx_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from xlsx file.\" ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get () split_column_name ( column ) \u00b6 Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse.py 115 116 117 118 119 120 121 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit parse_image \u00b6 Strategy class for parsing an image to a DLite instance. DLiteImageConfig \u00b6 Bases: BaseModel Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class DLiteImageConfig ( BaseModel ): \"\"\"Configuration for DLite image parser.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\"Initialize image configuration object.\"\"\" super () . __init__ () if not kwargs : return config = kwargs . copy () if \"crop\" in config : self . crop = config . pop ( \"crop\" , self . crop ) if \"given_id\" in config : self . given_id = config . pop ( \"given_id\" , self . given_id ) if \"metadata\" in config : self . metadata = config . pop ( \"metadata\" , self . metadata ) if config : self . configuration = config configuration : Optional [ Dict [ str , Any ]] = Field ( None , description = \"Specific image configuration parameters.\" ) crop : Optional [ Tuple ] = Field ( None , description = \"Cropping rectangle. The whole image if None.\" ) given_id : Optional [ str ] = Field ( None , description = \"Optional id for new instance.\" ) metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the image file.\" ), ) __init__ ( self , ** kwargs ) \u00b6 Initialize image configuration object. Source code in oteapi_dlite/strategies/parse_image.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , ** kwargs ) -> None : \"\"\"Initialize image configuration object.\"\"\" super () . __init__ () if not kwargs : return config = kwargs . copy () if \"crop\" in config : self . crop = config . pop ( \"crop\" , self . crop ) if \"given_id\" in config : self . given_id = config . pop ( \"given_id\" , self . given_id ) if \"metadata\" in config : self . metadata = config . pop ( \"metadata\" , self . metadata ) if config : self . configuration = config DLiteImageParseStrategy \u00b6 Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/tiff\") Source code in oteapi_dlite/strategies/parse_image.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/tiff\")` \"\"\" META_PREFIX = \"http://onto-ns.com/meta/1.0/generated_from_\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session and \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) if image_config . metadata : raise NotImplementedError ( \"User-defined metadata for images not implemented\" ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = self . create_meta ( image , self . parse_config . mediaType , data . dtype . name , ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())], id = image_config . given_id , ) inst [ \"data\" ] = data if image . format : inst [ \"format\" ] = image . format # if image.info: # inst[\"info\"] = str(image.info) # if \"frames\" in inst: # inst[\"frames\"] = getattr(image, \"n_frames\") # inst[\"animated\"] = getattr(image, \"is_animated\", False) inst . incref () return SessionUpdate ( uuid = inst . uuid ) @classmethod def create_meta ( cls , image : Image , media_type : str , data_type : str ) -> \"Instance\" : \"\"\"Create DLite metadata from Image `image`.\"\"\" image_format = media_type . rpartition ( \"/\" )[ 2 ] rnd = getrandbits ( 128 ) uri = f \" { cls . META_PREFIX }{ image_format } _ { rnd : 0x } \" metadata = DataModel ( uri , description = f \"Generated datamodel from { image_format } file.\" ) metadata . add_dimension ( \"nheight\" , \"Vertical number of pixels.\" ) metadata . add_dimension ( \"nwidth\" , \"Horizontal number of pixels.\" ) metadata . add_dimension ( \"nbands\" , \"Number of bands per pixel.\" ) metadata . add_property ( \"data\" , data_type , [ \"nheight\" , \"nwidth\" , \"nbands\" ], description = \"The image contents.\" , ) if getattr ( image , \"format\" , None ): metadata . add_property ( \"format\" , \"string\" , description = \"The image format.\" , ) # if getattr(image, \"info\", None): # metadata.add_property( # \"info\", # \"string\", # description=\"Additional information.\", # ) # if getattr(image, \"n_frames\", 1) > 1: # metadata.add_property( # \"frames\", # dlite.UIntType, # description=\"Number of frames in the file.\", # ) # metadata.add_property( # \"animated\", # dlite.BoolType, # description=\"If the file contains an animation.\", # ) return metadata . get () create_meta ( cls , image , media_type , data_type ) \u00b6 Create DLite metadata from Image image . Source code in oteapi_dlite/strategies/parse_image.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @classmethod def create_meta ( cls , image : Image , media_type : str , data_type : str ) -> \"Instance\" : \"\"\"Create DLite metadata from Image `image`.\"\"\" image_format = media_type . rpartition ( \"/\" )[ 2 ] rnd = getrandbits ( 128 ) uri = f \" { cls . META_PREFIX }{ image_format } _ { rnd : 0x } \" metadata = DataModel ( uri , description = f \"Generated datamodel from { image_format } file.\" ) metadata . add_dimension ( \"nheight\" , \"Vertical number of pixels.\" ) metadata . add_dimension ( \"nwidth\" , \"Horizontal number of pixels.\" ) metadata . add_dimension ( \"nbands\" , \"Number of bands per pixel.\" ) metadata . add_property ( \"data\" , data_type , [ \"nheight\" , \"nwidth\" , \"nbands\" ], description = \"The image contents.\" , ) if getattr ( image , \"format\" , None ): metadata . add_property ( \"format\" , \"string\" , description = \"The image format.\" , ) # if getattr(image, \"info\", None): # metadata.add_property( # \"info\", # \"string\", # description=\"Additional information.\", # ) # if getattr(image, \"n_frames\", 1) > 1: # metadata.add_property( # \"frames\", # dlite.UIntType, # description=\"Number of frames in the file.\", # ) # metadata.add_property( # \"animated\", # dlite.BoolType, # description=\"If the file contains an animation.\", # ) return metadata . get () get ( self , session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session and \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) if image_config . metadata : raise NotImplementedError ( \"User-defined metadata for images not implemented\" ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = self . create_meta ( image , self . parse_config . mediaType , data . dtype . name , ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())], id = image_config . given_id , ) inst [ \"data\" ] = data if image . format : inst [ \"format\" ] = image . format # if image.info: # inst[\"info\"] = str(image.info) # if \"frames\" in inst: # inst[\"frames\"] = getattr(image, \"n_frames\") # inst[\"animated\"] = getattr(image, \"is_animated\", False) inst . incref () return SessionUpdate ( uuid = inst . uuid ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse_image.py 76 77 78 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" SessionUpdate ()","title":"OTEAPI DLite Plugin Strategies"},{"location":"all_strategies/#oteapi-dlite-plugin-strategies","text":"This page provides documentation for the oteapi_dlite.strategies submodule, where all the OTEAPI DLite Plugin strategies are located. These strategies will be available when setting up a server in an environment with oteapi-dlite installed.","title":"OTEAPI DLite Plugin Strategies"},{"location":"all_strategies/#oteapi_dlite.strategies.parse","text":"Strategy class for parsing Excel XLSX to a DLite instance.","title":"parse"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteXLSXConfig","text":"Bases: BaseModel Configuration for DLite XLSX parser. Source code in oteapi_dlite/strategies/parse.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class DLiteXLSXConfig ( BaseModel ): \"\"\"Configuration for DLite XLSX parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) xlsx_config : XLSXParseDataModel = Field ( ... , description = \"Excel XLSX configurations.\" , )","title":"DLiteXLSXConfig"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteXLSXStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @dataclass class DLiteXLSXStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , )","title":"DLiteXLSXStrategy"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteXLSXStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'Dict[str, Any]' DLite instance. Source code in oteapi_dlite/strategies/parse.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , )","title":"get()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.DLiteXLSXStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse.py 59 60 61 62 63 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.infer_metadata","text":"Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse.py 124 125 126 127 128 129 130 131 132 133 134 def infer_metadata ( rec : np . recarray , units : list ) -> \"dlite.Instance\" : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_xlsx_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from xlsx file.\" ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get ()","title":"infer_metadata()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse.split_column_name","text":"Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse.py 115 116 117 118 119 120 121 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"split_column_name()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image","text":"Strategy class for parsing an image to a DLite instance.","title":"parse_image"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageConfig","text":"Bases: BaseModel Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class DLiteImageConfig ( BaseModel ): \"\"\"Configuration for DLite image parser.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\"Initialize image configuration object.\"\"\" super () . __init__ () if not kwargs : return config = kwargs . copy () if \"crop\" in config : self . crop = config . pop ( \"crop\" , self . crop ) if \"given_id\" in config : self . given_id = config . pop ( \"given_id\" , self . given_id ) if \"metadata\" in config : self . metadata = config . pop ( \"metadata\" , self . metadata ) if config : self . configuration = config configuration : Optional [ Dict [ str , Any ]] = Field ( None , description = \"Specific image configuration parameters.\" ) crop : Optional [ Tuple ] = Field ( None , description = \"Cropping rectangle. The whole image if None.\" ) given_id : Optional [ str ] = Field ( None , description = \"Optional id for new instance.\" ) metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the image file.\" ), )","title":"DLiteImageConfig"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageConfig.__init__","text":"Initialize image configuration object. Source code in oteapi_dlite/strategies/parse_image.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , ** kwargs ) -> None : \"\"\"Initialize image configuration object.\"\"\" super () . __init__ () if not kwargs : return config = kwargs . copy () if \"crop\" in config : self . crop = config . pop ( \"crop\" , self . crop ) if \"given_id\" in config : self . given_id = config . pop ( \"given_id\" , self . given_id ) if \"metadata\" in config : self . metadata = config . pop ( \"metadata\" , self . metadata ) if config : self . configuration = config","title":"__init__()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy","text":"Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/tiff\") Source code in oteapi_dlite/strategies/parse_image.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/tiff\")` \"\"\" META_PREFIX = \"http://onto-ns.com/meta/1.0/generated_from_\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session and \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) if image_config . metadata : raise NotImplementedError ( \"User-defined metadata for images not implemented\" ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = self . create_meta ( image , self . parse_config . mediaType , data . dtype . name , ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())], id = image_config . given_id , ) inst [ \"data\" ] = data if image . format : inst [ \"format\" ] = image . format # if image.info: # inst[\"info\"] = str(image.info) # if \"frames\" in inst: # inst[\"frames\"] = getattr(image, \"n_frames\") # inst[\"animated\"] = getattr(image, \"is_animated\", False) inst . incref () return SessionUpdate ( uuid = inst . uuid ) @classmethod def create_meta ( cls , image : Image , media_type : str , data_type : str ) -> \"Instance\" : \"\"\"Create DLite metadata from Image `image`.\"\"\" image_format = media_type . rpartition ( \"/\" )[ 2 ] rnd = getrandbits ( 128 ) uri = f \" { cls . META_PREFIX }{ image_format } _ { rnd : 0x } \" metadata = DataModel ( uri , description = f \"Generated datamodel from { image_format } file.\" ) metadata . add_dimension ( \"nheight\" , \"Vertical number of pixels.\" ) metadata . add_dimension ( \"nwidth\" , \"Horizontal number of pixels.\" ) metadata . add_dimension ( \"nbands\" , \"Number of bands per pixel.\" ) metadata . add_property ( \"data\" , data_type , [ \"nheight\" , \"nwidth\" , \"nbands\" ], description = \"The image contents.\" , ) if getattr ( image , \"format\" , None ): metadata . add_property ( \"format\" , \"string\" , description = \"The image format.\" , ) # if getattr(image, \"info\", None): # metadata.add_property( # \"info\", # \"string\", # description=\"Additional information.\", # ) # if getattr(image, \"n_frames\", 1) > 1: # metadata.add_property( # \"frames\", # dlite.UIntType, # description=\"Number of frames in the file.\", # ) # metadata.add_property( # \"animated\", # dlite.BoolType, # description=\"If the file contains an animation.\", # ) return metadata . get ()","title":"DLiteImageParseStrategy"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.create_meta","text":"Create DLite metadata from Image image . Source code in oteapi_dlite/strategies/parse_image.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @classmethod def create_meta ( cls , image : Image , media_type : str , data_type : str ) -> \"Instance\" : \"\"\"Create DLite metadata from Image `image`.\"\"\" image_format = media_type . rpartition ( \"/\" )[ 2 ] rnd = getrandbits ( 128 ) uri = f \" { cls . META_PREFIX }{ image_format } _ { rnd : 0x } \" metadata = DataModel ( uri , description = f \"Generated datamodel from { image_format } file.\" ) metadata . add_dimension ( \"nheight\" , \"Vertical number of pixels.\" ) metadata . add_dimension ( \"nwidth\" , \"Horizontal number of pixels.\" ) metadata . add_dimension ( \"nbands\" , \"Number of bands per pixel.\" ) metadata . add_property ( \"data\" , data_type , [ \"nheight\" , \"nwidth\" , \"nbands\" ], description = \"The image contents.\" , ) if getattr ( image , \"format\" , None ): metadata . add_property ( \"format\" , \"string\" , description = \"The image format.\" , ) # if getattr(image, \"info\", None): # metadata.add_property( # \"info\", # \"string\", # description=\"Additional information.\", # ) # if getattr(image, \"n_frames\", 1) > 1: # metadata.add_property( # \"frames\", # dlite.UIntType, # description=\"Number of frames in the file.\", # ) # metadata.add_property( # \"animated\", # dlite.BoolType, # description=\"If the file contains an animation.\", # ) return metadata . get ()","title":"create_meta()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session and \"key\" in session : key = session [ \"key\" ] elif \"key\" in self . parse_config . configuration : key = self . parse_config . configuration [ \"key\" ] else : raise RuntimeError ( \"Image parser needs an image to parse\" ) image_config = DLiteImageConfig ( ** self . parse_config . configuration ) if image_config . metadata : raise NotImplementedError ( \"User-defined metadata for images not implemented\" ) with DataCache () . getfile ( key , suffix = self . parse_config . mediaType . split ( \"/\" )[ 1 ] ) as tmp_file : if image_config . crop : tmp_config = self . parse_config . copy () tmp_config . configuration [ \"filename\" ] = tmp_file . name tmp_config . configuration [ \"localpath\" ] = tmp_file . parent image = Image . open ( BytesIO ( ImageDataParseStrategy ( tmp_config ) . get () . content ) ) else : image = Image . open ( tmp_file ) . copy () data = np . asarray ( image ) if np . ndim ( data ) == 2 : data . shape = ( data . shape [ 0 ], data . shape [ 1 ], 1 ) meta = self . create_meta ( image , self . parse_config . mediaType , data . dtype . name , ) inst = meta ( dims = [ image . height , image . width , len ( image . getbands ())], id = image_config . given_id , ) inst [ \"data\" ] = data if image . format : inst [ \"format\" ] = image . format # if image.info: # inst[\"info\"] = str(image.info) # if \"frames\" in inst: # inst[\"frames\"] = getattr(image, \"n_frames\") # inst[\"animated\"] = getattr(image, \"is_animated\", False) inst . incref () return SessionUpdate ( uuid = inst . uuid )","title":"get()"},{"location":"all_strategies/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse_image.py 76 77 78 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/","text":"parse \u00b6 Strategy class for parsing Excel XLSX to a DLite instance. DLiteXLSXConfig \u00b6 Bases: BaseModel Configuration for DLite XLSX parser. Source code in oteapi_dlite/strategies/parse.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class DLiteXLSXConfig ( BaseModel ): \"\"\"Configuration for DLite XLSX parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) xlsx_config : XLSXParseDataModel = Field ( ... , description = \"Excel XLSX configurations.\" , ) DLiteXLSXStrategy \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @dataclass class DLiteXLSXStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , ) get ( self , session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'Dict[str, Any]' DLite instance. Source code in oteapi_dlite/strategies/parse.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse.py 59 60 61 62 63 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate () infer_metadata ( rec , units ) \u00b6 Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse.py 124 125 126 127 128 129 130 131 132 133 134 def infer_metadata ( rec : np . recarray , units : list ) -> \"dlite.Instance\" : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_xlsx_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from xlsx file.\" ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get () split_column_name ( column ) \u00b6 Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse.py 115 116 117 118 119 120 121 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"parse"},{"location":"api_reference/strategies/parse/#parse","text":"Strategy class for parsing Excel XLSX to a DLite instance.","title":"parse"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteXLSXConfig","text":"Bases: BaseModel Configuration for DLite XLSX parser. Source code in oteapi_dlite/strategies/parse.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class DLiteXLSXConfig ( BaseModel ): \"\"\"Configuration for DLite XLSX parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) xlsx_config : XLSXParseDataModel = Field ( ... , description = \"Excel XLSX configurations.\" , )","title":"DLiteXLSXConfig"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteXLSXStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @dataclass class DLiteXLSXStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , )","title":"DLiteXLSXStrategy"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteXLSXStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'Dict[str, Any]' DLite instance. Source code in oteapi_dlite/strategies/parse.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = DLiteXLSXConfig ( ** self . parse_config . configuration ) parse_config = self . parse_config . copy () parse_config . configuration = config . xlsx_config . dict () parser = XLSXParseStrategy ( parse_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : # pylint: disable=no-else-raise raise NotImplementedError ( \"\" ) else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . incref () return SessionUpdate ( inst_uuid = inst . uuid , collection_id = coll . uuid , label = config . label , )","title":"get()"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteXLSXStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse.py 59 60 61 62 63 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.infer_metadata","text":"Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse.py 124 125 126 127 128 129 130 131 132 133 134 def infer_metadata ( rec : np . recarray , units : list ) -> \"dlite.Instance\" : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_xlsx_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from xlsx file.\" ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get ()","title":"infer_metadata()"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.split_column_name","text":"Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse.py 115 116 117 118 119 120 121 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"split_column_name()"},{"location":"api_reference/utils/nputils/","text":"nputils \u00b6 NumNy-related utility functions. dict2recarray ( excel_dict , names = None ) \u00b6 Converts a dict returned by the Excel parser to a numpy rec array. If names is None, the record names are inferred from excel_dict . Source code in oteapi_dlite/utils/nputils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def dict2recarray ( excel_dict , names = None ): \"\"\"Converts a dict returned by the Excel parser to a numpy rec array. If `names` is None, the record names are inferred from `excel_dict`. \"\"\" arrays = [] for arr in excel_dict . values (): if all ( isinstance ( v , ( bool , int , float , complex , None . __class__ )) for v in arr ): arrays . append ([ np . nan if v is None else v for v in arr ]) elif all ( isinstance ( v , ( str , bytes , None . __class__ )) for v in arr ): arrays . append ([ \"\" if v is None else v for v in arr ]) else : arrays . append ( arr ) if names is None : names = list ( excel_dict . keys ()) return np . rec . fromarrays ( arrays , names = names )","title":"nputils"},{"location":"api_reference/utils/nputils/#nputils","text":"NumNy-related utility functions.","title":"nputils"},{"location":"api_reference/utils/nputils/#oteapi_dlite.utils.nputils.dict2recarray","text":"Converts a dict returned by the Excel parser to a numpy rec array. If names is None, the record names are inferred from excel_dict . Source code in oteapi_dlite/utils/nputils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def dict2recarray ( excel_dict , names = None ): \"\"\"Converts a dict returned by the Excel parser to a numpy rec array. If `names` is None, the record names are inferred from `excel_dict`. \"\"\" arrays = [] for arr in excel_dict . values (): if all ( isinstance ( v , ( bool , int , float , complex , None . __class__ )) for v in arr ): arrays . append ([ np . nan if v is None else v for v in arr ]) elif all ( isinstance ( v , ( str , bytes , None . __class__ )) for v in arr ): arrays . append ([ \"\" if v is None else v for v in arr ]) else : arrays . append ( arr ) if names is None : names = list ( excel_dict . keys ()) return np . rec . fromarrays ( arrays , names = names )","title":"dict2recarray()"}]}