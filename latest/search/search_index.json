{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OTEAPI DLite Plugin \u00b6 All strategies implemented in this plugin (except for create_collection ) assumes that you have the UUID of a DLite collection with the key collection_id in the session : collection_id = session [ \"collection_id\" ] coll = dlite . get_collection ( collection_id ) A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case. In order to make it easy retrieve the collection id when executing a pipeline, the get() method of all filters in this plugin should return the collection_id . Further reading: OTE-API Core Documentation OTE-API Services Documentation DLite License and copyright \u00b6 The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF. Acknowledgment \u00b6 OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins . OTEAPI DLite Plugin has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136. VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903. OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.","title":"Home"},{"location":"#oteapi-dlite-plugin","text":"All strategies implemented in this plugin (except for create_collection ) assumes that you have the UUID of a DLite collection with the key collection_id in the session : collection_id = session [ \"collection_id\" ] coll = dlite . get_collection ( collection_id ) A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case. In order to make it easy retrieve the collection id when executing a pipeline, the get() method of all filters in this plugin should return the collection_id . Further reading: OTE-API Core Documentation OTE-API Services Documentation DLite","title":"OTEAPI DLite Plugin"},{"location":"#license-and-copyright","text":"The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF.","title":"License and copyright"},{"location":"#acknowledgment","text":"OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins . OTEAPI DLite Plugin has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136. VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903. OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.","title":"Acknowledgment"},{"location":"CHANGELOG/","text":"Changelog \u00b6 This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"all_strategies/","text":"OTEAPI DLite Plugin Strategies \u00b6 This page provides documentation for the oteapi_dlite.strategies submodule, where all the OTEAPI DLite Plugin strategies are located. These strategies will be available when setting up a server in an environment with oteapi-dlite installed.","title":"OTEAPI DLite Plugin Strategies"},{"location":"all_strategies/#oteapi-dlite-plugin-strategies","text":"This page provides documentation for the oteapi_dlite.strategies submodule, where all the OTEAPI DLite Plugin strategies are located. These strategies will be available when setting up a server in an environment with oteapi-dlite installed.","title":"OTEAPI DLite Plugin Strategies"},{"location":"api_reference/models/session/","text":"session \u00b6 Pydantic data models for DLite. DLiteSessionUpdate \u00b6 Bases: SessionUpdate Class for returning values from DLite strategies. Source code in oteapi_dlite/models/session.py 8 9 10 11 12 13 14 class DLiteSessionUpdate ( SessionUpdate ): \"\"\"Class for returning values from DLite strategies.\"\"\" collection_id : Optional [ str ] = Field ( {}, # default_factory=new_collection, description = \"A reference to a DLite collection.\" , ) collection_id : Optional [ str ] = Field ({}, description = 'A reference to a DLite collection.' ) class-attribute \u00b6","title":"session"},{"location":"api_reference/models/session/#session","text":"Pydantic data models for DLite.","title":"session"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate","text":"Bases: SessionUpdate Class for returning values from DLite strategies. Source code in oteapi_dlite/models/session.py 8 9 10 11 12 13 14 class DLiteSessionUpdate ( SessionUpdate ): \"\"\"Class for returning values from DLite strategies.\"\"\" collection_id : Optional [ str ] = Field ( {}, # default_factory=new_collection, description = \"A reference to a DLite collection.\" , )","title":"DLiteSessionUpdate"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate.collection_id","text":"","title":"collection_id"},{"location":"api_reference/strategies/filter/","text":"filter \u00b6 Trivial filter that adds an empty collection to the session. CreateCollectionStrategy \u00b6 Trivial filter that adds an empty collection to the session. Registers strategies : (\"filterType\", \"dlite/create-collection\") Source code in oteapi_dlite/strategies/filter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 @dataclass class CreateCollectionStrategy : \"\"\"Trivial filter that adds an empty collection to the session. **Registers strategies**: - `(\"filterType\", \"dlite/create-collection\")` \"\"\" filter_config : FilterConfig # Find a better way to keep collections alive!!! # Need to be `Any`, because otherwise `pydantic` complains. collection_refs : Dict [ str , Any ] = Field ( {}, description = \"A dictionary of DLite Collections.\" , ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Make sure that collection stays alive # It will never be deallocated... coll . _incref () # pylint: disable=protected-access return DLiteSessionUpdate ( collection_id = coll . uuid ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi_dlite/strategies/filter.py 51 52 53 54 55 56 57 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/filter.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Make sure that collection stays alive # It will never be deallocated... coll . _incref () # pylint: disable=protected-access return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"filter"},{"location":"api_reference/strategies/filter/#filter","text":"Trivial filter that adds an empty collection to the session.","title":"filter"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy","text":"Trivial filter that adds an empty collection to the session. Registers strategies : (\"filterType\", \"dlite/create-collection\") Source code in oteapi_dlite/strategies/filter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 @dataclass class CreateCollectionStrategy : \"\"\"Trivial filter that adds an empty collection to the session. **Registers strategies**: - `(\"filterType\", \"dlite/create-collection\")` \"\"\" filter_config : FilterConfig # Find a better way to keep collections alive!!! # Need to be `Any`, because otherwise `pydantic` complains. collection_refs : Dict [ str , Any ] = Field ( {}, description = \"A dictionary of DLite Collections.\" , ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Make sure that collection stays alive # It will never be deallocated... coll . _incref () # pylint: disable=protected-access return DLiteSessionUpdate ( collection_id = coll . uuid ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"CreateCollectionStrategy"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.get","text":"Execute the strategy. Source code in oteapi_dlite/strategies/filter.py 51 52 53 54 55 56 57 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"get()"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/filter.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" in session : raise KeyError ( \"`collection_id` already exists in session.\" ) coll = dlite . Collection () # Make sure that collection stays alive # It will never be deallocated... coll . _incref () # pylint: disable=protected-access return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"initialize()"},{"location":"api_reference/strategies/function/","text":"function \u00b6 Generic function strategy using DLite storage plugin. DLiteFunctionConfig \u00b6 Bases: FunctionConfig DLite function strategy config. Source code in oteapi_dlite/strategies/function.py 68 69 70 71 72 73 class DLiteFunctionConfig ( FunctionConfig ): \"\"\"DLite function strategy config.\"\"\" configuration : DLiteStorageConfig = Field ( ... , description = \"DLite function strategy-specific configuration.\" ) DLiteFunctionStrategy \u00b6 Generic DLite function strategy utilising DLite storage plugins. Registers strategies : (\"mediaType\", \"application/vnd.dlite-generate\") Source code in oteapi_dlite/strategies/function.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @dataclass class DLiteFunctionStrategy : \"\"\"Generic DLite function strategy utilising DLite storage plugins. **Registers strategies**: - `(\"mediaType\", \"application/vnd.dlite-generate\")` \"\"\" function_config : DLiteFunctionConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . function_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = config . mediaType , ) ) coll = get_collection ( session ) inst = coll [ config . label ] # Save instance if config . location : inst . save ( driver , config . location , config . options ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif \"key\" in session : # type: ignore key = \"function_data\" cache = DataCache () with tempfile . TemporaryDirectory () as tmpdir : inst . save ( driver , \" {tmpdir} /data\" , config . options ) with open ( f \" { tmpdir } /data\" , \"rb\" ) as f : cache . add ( f . read (), key = key ) # __TODO__ # Can we savely assume that all strategies in a pipeline will be # executed in the same Python interpreter? If not, we should write # the collection to a storage, such that it can be shared with the # other strategies. return DLiteSessionUpdate ( collection_id = coll . uuid ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate SessionUpdate instance. Source code in oteapi_dlite/strategies/function.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . function_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = config . mediaType , ) ) coll = get_collection ( session ) inst = coll [ config . label ] # Save instance if config . location : inst . save ( driver , config . location , config . options ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif \"key\" in session : # type: ignore key = \"function_data\" cache = DataCache () with tempfile . TemporaryDirectory () as tmpdir : inst . save ( driver , \" {tmpdir} /data\" , config . options ) with open ( f \" { tmpdir } /data\" , \"rb\" ) as f : cache . add ( f . read (), key = key ) # __TODO__ # Can we savely assume that all strategies in a pipeline will be # executed in the same Python interpreter? If not, we should write # the collection to a storage, such that it can be shared with the # other strategies. return DLiteSessionUpdate ( collection_id = coll . uuid ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/function.py 88 89 90 91 92 93 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate () DLiteStorageConfig \u00b6 Bases: AttrDict Configuration for a generic DLite storage filter. The DLite storage driver to can be specified using either the driver or mediaType field. Where the output should be written, is specified using either the location or datacache_config.accessKey field. Source code in oteapi_dlite/strategies/function.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class DLiteStorageConfig ( AttrDict ): \"\"\"Configuration for a generic DLite storage filter. The DLite storage driver to can be specified using either the `driver` or `mediaType` field. Where the output should be written, is specified using either the `location` or `datacache_config.accessKey` field. \"\"\" driver : Optional [ str ] = Field ( None , description = 'Name of DLite driver (ex: \"json\").' , ) mediaType : Optional [ str ] = Field ( None , description = 'Media type for DLite driver (ex: \"application/json\").' , ) location : Optional [ str ] = Field ( None , description = ( \"Location of storage to write to. If unset to store in data \" \"cache using the key provided with `datacache_config.accessKey` \" \"(defaults to 'function_data').\" ), ) options : Optional [ str ] = Field ( None , description = ( \"Comma-separated list of options passed to the DLite \" \"storage plugin.\" ), ) label : str = Field ( ... , description = \"Label of DLite instance to serialise in the collection.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , )","title":"function"},{"location":"api_reference/strategies/function/#function","text":"Generic function strategy using DLite storage plugin.","title":"function"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionConfig","text":"Bases: FunctionConfig DLite function strategy config. Source code in oteapi_dlite/strategies/function.py 68 69 70 71 72 73 class DLiteFunctionConfig ( FunctionConfig ): \"\"\"DLite function strategy config.\"\"\" configuration : DLiteStorageConfig = Field ( ... , description = \"DLite function strategy-specific configuration.\" )","title":"DLiteFunctionConfig"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionStrategy","text":"Generic DLite function strategy utilising DLite storage plugins. Registers strategies : (\"mediaType\", \"application/vnd.dlite-generate\") Source code in oteapi_dlite/strategies/function.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @dataclass class DLiteFunctionStrategy : \"\"\"Generic DLite function strategy utilising DLite storage plugins. **Registers strategies**: - `(\"mediaType\", \"application/vnd.dlite-generate\")` \"\"\" function_config : DLiteFunctionConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . function_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = config . mediaType , ) ) coll = get_collection ( session ) inst = coll [ config . label ] # Save instance if config . location : inst . save ( driver , config . location , config . options ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif \"key\" in session : # type: ignore key = \"function_data\" cache = DataCache () with tempfile . TemporaryDirectory () as tmpdir : inst . save ( driver , \" {tmpdir} /data\" , config . options ) with open ( f \" { tmpdir } /data\" , \"rb\" ) as f : cache . add ( f . read (), key = key ) # __TODO__ # Can we savely assume that all strategies in a pipeline will be # executed in the same Python interpreter? If not, we should write # the collection to a storage, such that it can be shared with the # other strategies. return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"DLiteFunctionStrategy"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate SessionUpdate instance. Source code in oteapi_dlite/strategies/function.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . function_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = config . mediaType , ) ) coll = get_collection ( session ) inst = coll [ config . label ] # Save instance if config . location : inst . save ( driver , config . location , config . options ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif \"key\" in session : # type: ignore key = \"function_data\" cache = DataCache () with tempfile . TemporaryDirectory () as tmpdir : inst . save ( driver , \" {tmpdir} /data\" , config . options ) with open ( f \" { tmpdir } /data\" , \"rb\" ) as f : cache . add ( f . read (), key = key ) # __TODO__ # Can we savely assume that all strategies in a pipeline will be # executed in the same Python interpreter? If not, we should write # the collection to a storage, such that it can be shared with the # other strategies. return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"get()"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/function.py 88 89 90 91 92 93 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteStorageConfig","text":"Bases: AttrDict Configuration for a generic DLite storage filter. The DLite storage driver to can be specified using either the driver or mediaType field. Where the output should be written, is specified using either the location or datacache_config.accessKey field. Source code in oteapi_dlite/strategies/function.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class DLiteStorageConfig ( AttrDict ): \"\"\"Configuration for a generic DLite storage filter. The DLite storage driver to can be specified using either the `driver` or `mediaType` field. Where the output should be written, is specified using either the `location` or `datacache_config.accessKey` field. \"\"\" driver : Optional [ str ] = Field ( None , description = 'Name of DLite driver (ex: \"json\").' , ) mediaType : Optional [ str ] = Field ( None , description = 'Media type for DLite driver (ex: \"application/json\").' , ) location : Optional [ str ] = Field ( None , description = ( \"Location of storage to write to. If unset to store in data \" \"cache using the key provided with `datacache_config.accessKey` \" \"(defaults to 'function_data').\" ), ) options : Optional [ str ] = Field ( None , description = ( \"Comma-separated list of options passed to the DLite \" \"storage plugin.\" ), ) label : str = Field ( ... , description = \"Label of DLite instance to serialise in the collection.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , )","title":"DLiteStorageConfig"},{"location":"api_reference/strategies/parse/","text":"parse \u00b6 Generic parse strategy using DLite storage plugin. DLiteParseConfig \u00b6 Bases: AttrDict Configuration for generic DLite parser. Source code in oteapi_dlite/strategies/parse.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class DLiteParseConfig ( AttrDict ): \"\"\"Configuration for generic DLite parser.\"\"\" driver : Optional [ str ] = Field ( None , description = 'Name of DLite driver (ex: \"json\").' , ) location : Optional [ str ] = Field ( None , description = ( \"Explicit location of storage. Normally data is read from the \" \"data cache using `datacache_config.accessKey` (default: 'key').\" ), ) options : Optional [ str ] = Field ( None , description = ( \"Comma-separated list of options passed to the DLite storage \" \"plugin.\" ), ) id : Optional [ str ] = Field ( None , description = \"If given, the id of the instance in the storage.\" , ) label : str = Field ( ... , description = \"Label of the new DLite instance in the collection.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , ) DLiteParseResourceConfig \u00b6 Bases: ResourceConfig DLite parse strategy resource config. Source code in oteapi_dlite/strategies/parse.py 60 61 62 63 64 65 class DLiteParseResourceConfig ( ResourceConfig ): \"\"\"DLite parse strategy resource config.\"\"\" configuration : DLiteParseConfig = Field ( ... , description = \"DLite parse strategy-specific configuration.\" ) DLiteParseStrategy \u00b6 Generic DLite parse strategy utilising DLite storage plugins. Registers strategies : (\"mediaType\", \"application/vnd.dlite-parse\") Source code in oteapi_dlite/strategies/parse.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @dataclass class DLiteParseStrategy : \"\"\"Generic DLite parse strategy utilising DLite storage plugins. **Registers strategies**: - `(\"mediaType\", \"application/vnd.dlite-parse\")` \"\"\" parse_config : DLiteParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . parse_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = self . parse_config . mediaType , ) ) # Create instance if config . location : inst = dlite . Instance . from_location ( driver = driver , location = config . location , options = config . options , id = config . id , ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif session and \"key\" in session : key = session [ \"key\" ] else : raise ValueError ( \"either `location` or `cacheconfig.accessKey` must be \" \"provided\" ) cache = DataCache () with cache . getfile ( key ) as location : inst = dlite . Instance . from_location ( driver = driver , location = str ( location ), options = config . options , id = config . id , ) # Insert inst into collection coll = get_collection ( session ) coll . add ( config . label , inst ) # __TODO__ # See # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185 # and following comments. # # Since we cannot safely assume that all strategies in a # pipeline will be executed in the same Python interpreter, # the collection should be written to a storage, such that it # can be shared with the other strategies. # return DLiteSessionUpdate ( collection_id = coll . uuid ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate SessionUpdate instance. Source code in oteapi_dlite/strategies/parse.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . parse_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = self . parse_config . mediaType , ) ) # Create instance if config . location : inst = dlite . Instance . from_location ( driver = driver , location = config . location , options = config . options , id = config . id , ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif session and \"key\" in session : key = session [ \"key\" ] else : raise ValueError ( \"either `location` or `cacheconfig.accessKey` must be \" \"provided\" ) cache = DataCache () with cache . getfile ( key ) as location : inst = dlite . Instance . from_location ( driver = driver , location = str ( location ), options = config . options , id = config . id , ) # Insert inst into collection coll = get_collection ( session ) coll . add ( config . label , inst ) # __TODO__ # See # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185 # and following comments. # # Since we cannot safely assume that all strategies in a # pipeline will be executed in the same Python interpreter, # the collection should be written to a storage, such that it # can be shared with the other strategies. # return DLiteSessionUpdate ( collection_id = coll . uuid ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse.py 80 81 82 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"parse"},{"location":"api_reference/strategies/parse/#parse","text":"Generic parse strategy using DLite storage plugin.","title":"parse"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig","text":"Bases: AttrDict Configuration for generic DLite parser. Source code in oteapi_dlite/strategies/parse.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class DLiteParseConfig ( AttrDict ): \"\"\"Configuration for generic DLite parser.\"\"\" driver : Optional [ str ] = Field ( None , description = 'Name of DLite driver (ex: \"json\").' , ) location : Optional [ str ] = Field ( None , description = ( \"Explicit location of storage. Normally data is read from the \" \"data cache using `datacache_config.accessKey` (default: 'key').\" ), ) options : Optional [ str ] = Field ( None , description = ( \"Comma-separated list of options passed to the DLite storage \" \"plugin.\" ), ) id : Optional [ str ] = Field ( None , description = \"If given, the id of the instance in the storage.\" , ) label : str = Field ( ... , description = \"Label of the new DLite instance in the collection.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , )","title":"DLiteParseConfig"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseResourceConfig","text":"Bases: ResourceConfig DLite parse strategy resource config. Source code in oteapi_dlite/strategies/parse.py 60 61 62 63 64 65 class DLiteParseResourceConfig ( ResourceConfig ): \"\"\"DLite parse strategy resource config.\"\"\" configuration : DLiteParseConfig = Field ( ... , description = \"DLite parse strategy-specific configuration.\" )","title":"DLiteParseResourceConfig"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy","text":"Generic DLite parse strategy utilising DLite storage plugins. Registers strategies : (\"mediaType\", \"application/vnd.dlite-parse\") Source code in oteapi_dlite/strategies/parse.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @dataclass class DLiteParseStrategy : \"\"\"Generic DLite parse strategy utilising DLite storage plugins. **Registers strategies**: - `(\"mediaType\", \"application/vnd.dlite-parse\")` \"\"\" parse_config : DLiteParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . parse_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = self . parse_config . mediaType , ) ) # Create instance if config . location : inst = dlite . Instance . from_location ( driver = driver , location = config . location , options = config . options , id = config . id , ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif session and \"key\" in session : key = session [ \"key\" ] else : raise ValueError ( \"either `location` or `cacheconfig.accessKey` must be \" \"provided\" ) cache = DataCache () with cache . getfile ( key ) as location : inst = dlite . Instance . from_location ( driver = driver , location = str ( location ), options = config . options , id = config . id , ) # Insert inst into collection coll = get_collection ( session ) coll . add ( config . label , inst ) # __TODO__ # See # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185 # and following comments. # # Since we cannot safely assume that all strategies in a # pipeline will be executed in the same Python interpreter, # the collection should be written to a storage, such that it # can be shared with the other strategies. # return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"DLiteParseStrategy"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate SessionUpdate instance. Source code in oteapi_dlite/strategies/parse.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"DLiteSessionUpdate\" : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: SessionUpdate instance. \"\"\" config = self . parse_config . configuration cacheconfig = config . datacache_config driver = ( config . driver if config . driver else get_driver ( mediaType = self . parse_config . mediaType , ) ) # Create instance if config . location : inst = dlite . Instance . from_location ( driver = driver , location = config . location , options = config . options , id = config . id , ) else : if cacheconfig and cacheconfig . accessKey : key = cacheconfig . accessKey elif session and \"key\" in session : key = session [ \"key\" ] else : raise ValueError ( \"either `location` or `cacheconfig.accessKey` must be \" \"provided\" ) cache = DataCache () with cache . getfile ( key ) as location : inst = dlite . Instance . from_location ( driver = driver , location = str ( location ), options = config . options , id = config . id , ) # Insert inst into collection coll = get_collection ( session ) coll . add ( config . label , inst ) # __TODO__ # See # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185 # and following comments. # # Since we cannot safely assume that all strategies in a # pipeline will be executed in the same Python interpreter, # the collection should be written to a storage, such that it # can be shared with the other strategies. # return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"get()"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse.py 80 81 82 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> \"SessionUpdate\" : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse_excel/","text":"parse_excel \u00b6 Strategy for parsing an Excel spreadsheet to a DLite instance. DLiteExcelParseConfig \u00b6 Bases: AttrDict Configuration for DLite Excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class DLiteExcelParseConfig ( AttrDict ): \"\"\"Configuration for DLite Excel parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) excel_config : XLSXParseConfig = Field ( ... , description = \"DLite-specific excel configurations.\" , ) storage_path : Optional [ str ] = Field ( None , description = \"Path to metadata storage\" , ) DLiteExcelParseResourceConfig \u00b6 Bases: ResourceConfig DLite excel parse strategy resource config. Source code in oteapi_dlite/strategies/parse_excel.py 55 56 57 58 59 60 class DLiteExcelParseResourceConfig ( ResourceConfig ): \"\"\"DLite excel parse strategy resource config.\"\"\" configuration : DLiteExcelParseConfig = Field ( ... , description = \"DLite excel parse strategy-specific configuration.\" ) DLiteExcelSessionUpdate \u00b6 Bases: DLiteSessionUpdate Class for returning values from DLite excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 63 64 65 66 67 68 69 70 71 72 73 class DLiteExcelSessionUpdate ( DLiteSessionUpdate ): \"\"\"Class for returning values from DLite excel parser.\"\"\" inst_uuid : str = Field ( ... , description = \"UUID of new instance.\" , ) label : str = Field ( ... , description = \"Label of the new instance in the collection.\" , ) DLiteExcelStrategy \u00b6 Parse strategy for Excel files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse_excel.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @dataclass class DLiteExcelStrategy : \"\"\"Parse strategy for Excel files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : DLiteExcelParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration xlsx_config = self . parse_config . dict () xlsx_config [ \"configuration\" ] = config . excel_config xlsx_config [ \"mediaType\" ] = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" print ( xlsx_config ) parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : if config . storage_path is not None : for storage_path in config . storage_path . split ( \"|\" ): dlite . storage_path . append ( storage_path ) meta = dlite . get_instance ( config . metadata ) # check the metadata config would go here else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . _incref () # pylint: disable=protected-access return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_excel.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration xlsx_config = self . parse_config . dict () xlsx_config [ \"configuration\" ] = config . excel_config xlsx_config [ \"mediaType\" ] = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" print ( xlsx_config ) parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : if config . storage_path is not None : for storage_path in config . storage_path . split ( \"|\" ): dlite . storage_path . append ( storage_path ) meta = dlite . get_instance ( config . metadata ) # check the metadata config would go here else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . _incref () # pylint: disable=protected-access return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse_excel.py 89 90 91 92 93 94 95 96 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) infer_metadata ( rec , units ) \u00b6 Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse_excel.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def infer_metadata ( rec : np . recarray , units : list ) -> dlite . Instance : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_excel_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from excel file.\" , ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get () split_column_name ( column ) \u00b6 Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse_excel.py 156 157 158 159 160 161 162 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"parse_excel"},{"location":"api_reference/strategies/parse_excel/#parse_excel","text":"Strategy for parsing an Excel spreadsheet to a DLite instance.","title":"parse_excel"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig","text":"Bases: AttrDict Configuration for DLite Excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class DLiteExcelParseConfig ( AttrDict ): \"\"\"Configuration for DLite Excel parser.\"\"\" metadata : Optional [ HttpUrl ] = Field ( None , description = ( \"URI of DLite metadata to return. If not provided, the metadata \" \"will be inferred from the excel file.\" ), ) id : Optional [ str ] = Field ( None , description = \"Optional id on new instance.\" ) label : Optional [ str ] = Field ( \"excel-data\" , description = \"Optional label for new instance in collection.\" , ) excel_config : XLSXParseConfig = Field ( ... , description = \"DLite-specific excel configurations.\" , ) storage_path : Optional [ str ] = Field ( None , description = \"Path to metadata storage\" , )","title":"DLiteExcelParseConfig"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig","text":"Bases: ResourceConfig DLite excel parse strategy resource config. Source code in oteapi_dlite/strategies/parse_excel.py 55 56 57 58 59 60 class DLiteExcelParseResourceConfig ( ResourceConfig ): \"\"\"DLite excel parse strategy resource config.\"\"\" configuration : DLiteExcelParseConfig = Field ( ... , description = \"DLite excel parse strategy-specific configuration.\" )","title":"DLiteExcelParseResourceConfig"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate","text":"Bases: DLiteSessionUpdate Class for returning values from DLite excel parser. Source code in oteapi_dlite/strategies/parse_excel.py 63 64 65 66 67 68 69 70 71 72 73 class DLiteExcelSessionUpdate ( DLiteSessionUpdate ): \"\"\"Class for returning values from DLite excel parser.\"\"\" inst_uuid : str = Field ( ... , description = \"UUID of new instance.\" , ) label : str = Field ( ... , description = \"Label of the new instance in the collection.\" , )","title":"DLiteExcelSessionUpdate"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy","text":"Parse strategy for Excel files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi_dlite/strategies/parse_excel.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @dataclass class DLiteExcelStrategy : \"\"\"Parse strategy for Excel files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : DLiteExcelParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration xlsx_config = self . parse_config . dict () xlsx_config [ \"configuration\" ] = config . excel_config xlsx_config [ \"mediaType\" ] = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" print ( xlsx_config ) parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : if config . storage_path is not None : for storage_path in config . storage_path . split ( \"|\" ): dlite . storage_path . append ( storage_path ) meta = dlite . get_instance ( config . metadata ) # check the metadata config would go here else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . _incref () # pylint: disable=protected-access return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , )","title":"DLiteExcelStrategy"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_excel.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration xlsx_config = self . parse_config . dict () xlsx_config [ \"configuration\" ] = config . excel_config xlsx_config [ \"mediaType\" ] = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" print ( xlsx_config ) parser : \"IParseStrategy\" = XLSXParseStrategy ( xlsx_config ) columns = parser . get ( session )[ \"data\" ] names , units = zip ( * [ split_column_name ( column ) for column in columns ]) rec = dict2recarray ( columns , names = names ) if config . metadata : if config . storage_path is not None : for storage_path in config . storage_path . split ( \"|\" ): dlite . storage_path . append ( storage_path ) meta = dlite . get_instance ( config . metadata ) # check the metadata config would go here else : meta = infer_metadata ( rec , units = units ) inst = meta ( dims = [ len ( rec )], id = config . id ) for name in names : inst [ name ] = rec [ name ] # Insert inst into collection coll : dlite . Collection = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . label , inst ) # Increase refcount of instance to avoid that it is freed when # returning from this function inst . _incref () # pylint: disable=protected-access return DLiteExcelSessionUpdate ( collection_id = coll . uuid , inst_uuid = inst . uuid , label = config . label , )","title":"get()"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse_excel.py 89 90 91 92 93 94 95 96 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.infer_metadata","text":"Infer dlite metadata from recarray rec . Source code in oteapi_dlite/strategies/parse_excel.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def infer_metadata ( rec : np . recarray , units : list ) -> dlite . Instance : \"\"\"Infer dlite metadata from recarray `rec`.\"\"\" rnd = getrandbits ( 128 ) uri = f \"http://onto-ns.com/meta/1.0/generated_from_excel_ { rnd : 0x } \" metadata = DataModel ( uri , description = \"Generated datamodel from excel file.\" , ) metadata . add_dimension ( \"nrows\" , \"Number of rows.\" ) for i , name in enumerate ( rec . dtype . names ): dtype = rec [ name ] . dtype ptype = \"string\" if dtype . kind == \"U\" else dtype . name metadata . add_property ( name , type = ptype , dims = [ \"nrows\" ], unit = units [ i ]) return metadata . get ()","title":"infer_metadata()"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.split_column_name","text":"Split column name into a (name, unit) tuple. Source code in oteapi_dlite/strategies/parse_excel.py 156 157 158 159 160 161 162 def split_column_name ( column ): \"\"\"Split column name into a (name, unit) tuple.\"\"\" match = re . match ( r \"\\s*([^ ([<]+)\\s*[([<]?([^] )>]*)[])>]?\" , column ) if not match : return column , \"\" name , unit = match . groups () return name , unit","title":"split_column_name()"},{"location":"api_reference/strategies/parse_image/","text":"parse_image \u00b6 Strategy class for parsing an image to a DLite instance. DLiteImageConfig \u00b6 Bases: ImageParserConfig Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 27 28 29 30 31 32 33 class DLiteImageConfig ( ImageParserConfig ): \"\"\"Configuration for DLite image parser.\"\"\" image_label : str = Field ( \"image\" , description = \"Label to assign to the image in the collection.\" , ) DLiteImageParseStrategy \u00b6 Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/vnd.dlite-gif\") (\"mediaType\", \"image/vnd.dlite-jpeg\") (\"mediaType\", \"image/vnd.dlite-jpg\") (\"mediaType\", \"image/vnd.dlite-jp2\") (\"mediaType\", \"image/vnd.dlite-png\") (\"mediaType\", \"image/vnd.dlite-tiff\") Source code in oteapi_dlite/strategies/parse_image.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/vnd.dlite-gif\")` - `(\"mediaType\", \"image/vnd.dlite-jpeg\")` - `(\"mediaType\", \"image/vnd.dlite-jpg\")` - `(\"mediaType\", \"image/vnd.dlite-jp2\")` - `(\"mediaType\", \"image/vnd.dlite-png\")` - `(\"mediaType\", \"image/vnd.dlite-tiff\")` \"\"\" parse_config : DLiteImageResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration # Configuration for ImageDataParseStrategy in oteapi-core conf = self . parse_config . dict () conf [ \"configuration\" ] = ImageParserConfig ( ** config . dict (), extra = Extra . ignore , ) conf [ \"mediaType\" ] = \"image/\" + conf [ \"mediaType\" ] . split ( \"-\" )[ - 1 ] core_config = ImageParserResourceConfig ( ** conf ) ImageDataParseStrategy ( core_config ) . initialize ( session ) output = ImageDataParseStrategy ( core_config ) . get ( session ) cache = DataCache () data = cache . get ( output [ \"image_key\" ]) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = data . shape ) inst [ \"data\" ] = data LOGGER . info ( \"session: %s \" , session ) coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid ) get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration # Configuration for ImageDataParseStrategy in oteapi-core conf = self . parse_config . dict () conf [ \"configuration\" ] = ImageParserConfig ( ** config . dict (), extra = Extra . ignore , ) conf [ \"mediaType\" ] = \"image/\" + conf [ \"mediaType\" ] . split ( \"-\" )[ - 1 ] core_config = ImageParserResourceConfig ( ** conf ) ImageDataParseStrategy ( core_config ) . initialize ( session ) output = ImageDataParseStrategy ( core_config ) . get ( session ) cache = DataCache () data = cache . get ( output [ \"image_key\" ]) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = data . shape ) inst [ \"data\" ] = data LOGGER . info ( \"session: %s \" , session ) coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/parse_image.py 62 63 64 65 66 67 68 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) DLiteImageResourceConfig \u00b6 Bases: ResourceConfig Resource config for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 36 37 38 39 40 41 42 class DLiteImageResourceConfig ( ResourceConfig ): \"\"\"Resource config for DLite image parser.\"\"\" configuration : DLiteImageConfig = Field ( DLiteImageConfig (), description = \"Image parse strategy-specific configuration.\" , )","title":"parse_image"},{"location":"api_reference/strategies/parse_image/#parse_image","text":"Strategy class for parsing an image to a DLite instance.","title":"parse_image"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageConfig","text":"Bases: ImageParserConfig Configuration for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 27 28 29 30 31 32 33 class DLiteImageConfig ( ImageParserConfig ): \"\"\"Configuration for DLite image parser.\"\"\" image_label : str = Field ( \"image\" , description = \"Label to assign to the image in the collection.\" , )","title":"DLiteImageConfig"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy","text":"Parse strategy for image files. Registers strategies : (\"mediaType\", \"image/vnd.dlite-gif\") (\"mediaType\", \"image/vnd.dlite-jpeg\") (\"mediaType\", \"image/vnd.dlite-jpg\") (\"mediaType\", \"image/vnd.dlite-jp2\") (\"mediaType\", \"image/vnd.dlite-png\") (\"mediaType\", \"image/vnd.dlite-tiff\") Source code in oteapi_dlite/strategies/parse_image.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @dataclass class DLiteImageParseStrategy : \"\"\"Parse strategy for image files. **Registers strategies**: - `(\"mediaType\", \"image/vnd.dlite-gif\")` - `(\"mediaType\", \"image/vnd.dlite-jpeg\")` - `(\"mediaType\", \"image/vnd.dlite-jpg\")` - `(\"mediaType\", \"image/vnd.dlite-jp2\")` - `(\"mediaType\", \"image/vnd.dlite-png\")` - `(\"mediaType\", \"image/vnd.dlite-tiff\")` \"\"\" parse_config : DLiteImageResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration # Configuration for ImageDataParseStrategy in oteapi-core conf = self . parse_config . dict () conf [ \"configuration\" ] = ImageParserConfig ( ** config . dict (), extra = Extra . ignore , ) conf [ \"mediaType\" ] = \"image/\" + conf [ \"mediaType\" ] . split ( \"-\" )[ - 1 ] core_config = ImageParserResourceConfig ( ** conf ) ImageDataParseStrategy ( core_config ) . initialize ( session ) output = ImageDataParseStrategy ( core_config ) . get ( session ) cache = DataCache () data = cache . get ( output [ \"image_key\" ]) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = data . shape ) inst [ \"data\" ] = data LOGGER . info ( \"session: %s \" , session ) coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"DLiteImageParseStrategy"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description DLiteSessionUpdate DLite instance. Source code in oteapi_dlite/strategies/parse_image.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority). Parameters: session: A session-specific dictionary context. Returns: DLite instance. \"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . parse_config . configuration # Configuration for ImageDataParseStrategy in oteapi-core conf = self . parse_config . dict () conf [ \"configuration\" ] = ImageParserConfig ( ** config . dict (), extra = Extra . ignore , ) conf [ \"mediaType\" ] = \"image/\" + conf [ \"mediaType\" ] . split ( \"-\" )[ - 1 ] core_config = ImageParserResourceConfig ( ** conf ) ImageDataParseStrategy ( core_config ) . initialize ( session ) output = ImageDataParseStrategy ( core_config ) . get ( session ) cache = DataCache () data = cache . get ( output [ \"image_key\" ]) meta = get_meta ( \"http://onto-ns.com/meta/1.0/Image\" ) inst = meta ( dims = data . shape ) inst [ \"data\" ] = data LOGGER . info ( \"session: %s \" , session ) coll = dlite . get_collection ( session [ \"collection_id\" ]) coll . add ( config . image_label , inst ) return DLiteSessionUpdate ( collection_id = coll . uuid )","title":"get()"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/parse_image.py 62 63 64 65 66 67 68 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageResourceConfig","text":"Bases: ResourceConfig Resource config for DLite image parser. Source code in oteapi_dlite/strategies/parse_image.py 36 37 38 39 40 41 42 class DLiteImageResourceConfig ( ResourceConfig ): \"\"\"Resource config for DLite image parser.\"\"\" configuration : DLiteImageConfig = Field ( DLiteImageConfig (), description = \"Image parse strategy-specific configuration.\" , )","title":"DLiteImageResourceConfig"},{"location":"api_reference/strategies/serialise/","text":"serialise \u00b6 Filter for serialisation using DLite. SerialiseConfig \u00b6 Bases: AttrDict DLite serialise-specific configurations. Source code in oteapi_dlite/strategies/serialise.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SerialiseConfig ( AttrDict ): \"\"\"DLite serialise-specific configurations.\"\"\" driver : str = Field ( ... , description = \"Name of DLite plugin used for serialisation.\" , ) location : Path = Field ( ... , description = \"Path or URL to serialise to.\" , ) options : Optional [ str ] = Field ( \"\" , description = \"Options passed to the driver.\" , ) labels : Optional [ Sequence [ str ]] = Field ( None , description = ( \"Optional sequence of labels in the collection to serialise. \" \"The default is to serialise the entire collection.\" ), ) SerialiseFilterConfig \u00b6 Bases: FilterConfig Filter config for serialise. Source code in oteapi_dlite/strategies/serialise.py 40 41 42 43 44 45 46 class SerialiseFilterConfig ( FilterConfig ): \"\"\"Filter config for serialise.\"\"\" configuration : SerialiseConfig = Field ( ... , description = \"Serialise-specific configurations.\" , ) SerialiseStrategy \u00b6 Filter for serialisation using DLite. Registers strategies : (\"filterType\", \"dlite_serialise\") Source code in oteapi_dlite/strategies/serialise.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @dataclass class SerialiseStrategy : \"\"\"Filter for serialisation using DLite. **Registers strategies**: - `(\"filterType\", \"dlite_serialise\")` \"\"\" filter_config : SerialiseFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi_dlite/strategies/serialise.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi_dlite/strategies/serialise.py 61 62 63 64 65 66 67 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"serialise"},{"location":"api_reference/strategies/serialise/#serialise","text":"Filter for serialisation using DLite.","title":"serialise"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig","text":"Bases: AttrDict DLite serialise-specific configurations. Source code in oteapi_dlite/strategies/serialise.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SerialiseConfig ( AttrDict ): \"\"\"DLite serialise-specific configurations.\"\"\" driver : str = Field ( ... , description = \"Name of DLite plugin used for serialisation.\" , ) location : Path = Field ( ... , description = \"Path or URL to serialise to.\" , ) options : Optional [ str ] = Field ( \"\" , description = \"Options passed to the driver.\" , ) labels : Optional [ Sequence [ str ]] = Field ( None , description = ( \"Optional sequence of labels in the collection to serialise. \" \"The default is to serialise the entire collection.\" ), )","title":"SerialiseConfig"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig","text":"Bases: FilterConfig Filter config for serialise. Source code in oteapi_dlite/strategies/serialise.py 40 41 42 43 44 45 46 class SerialiseFilterConfig ( FilterConfig ): \"\"\"Filter config for serialise.\"\"\" configuration : SerialiseConfig = Field ( ... , description = \"Serialise-specific configurations.\" , )","title":"SerialiseFilterConfig"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy","text":"Filter for serialisation using DLite. Registers strategies : (\"filterType\", \"dlite_serialise\") Source code in oteapi_dlite/strategies/serialise.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @dataclass class SerialiseStrategy : \"\"\"Filter for serialisation using DLite. **Registers strategies**: - `(\"filterType\", \"dlite_serialise\")` \"\"\" filter_config : SerialiseFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ]) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"SerialiseStrategy"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.get","text":"Execute the strategy. Source code in oteapi_dlite/strategies/serialise.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Execute the strategy.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) config = self . filter_config . configuration coll = dlite . get_collection ( session [ \"collection_id\" ]) storage = dlite . Storage ( driver_or_url = config . driver , location = str ( config . location ), options = config . options , ) if config . labels is None : coll . save_to_storage ( storage ) else : for label in config . labels : inst = coll . get ( label ) inst . save_to_storage ( storage ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"get()"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.initialize","text":"Initialize. Source code in oteapi_dlite/strategies/serialise.py 61 62 63 64 65 66 67 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> DLiteSessionUpdate : \"\"\"Initialize.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) return DLiteSessionUpdate ( collection_id = session [ \"collection_id\" ])","title":"initialize()"},{"location":"api_reference/utils/nputils/","text":"nputils \u00b6 NumNy-related utility functions. dict2recarray ( excel_dict , names = None ) \u00b6 Converts a dict returned by the Excel parser to a numpy rec array. If names is None, the record names are inferred from excel_dict . Source code in oteapi_dlite/utils/nputils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dict2recarray ( excel_dict , names = None ): \"\"\"Converts a dict returned by the Excel parser to a numpy rec array. If `names` is None, the record names are inferred from `excel_dict`. \"\"\" arrays = [] for arr in excel_dict . values (): if all ( isinstance ( v , ( bool , int , float , complex , None . __class__ )) for v in arr ): arrays . append ([ np . nan if v is None else v for v in arr ]) elif all ( isinstance ( v , ( str , bytes , None . __class__ )) for v in arr ): arrays . append ([ \"\" if v is None else v for v in arr ]) else : arrays . append ( arr ) if names is None : names = list ( excel_dict . keys ()) return np . rec . fromarrays ( arrays , names = names )","title":"nputils"},{"location":"api_reference/utils/nputils/#nputils","text":"NumNy-related utility functions.","title":"nputils"},{"location":"api_reference/utils/nputils/#oteapi_dlite.utils.nputils.dict2recarray","text":"Converts a dict returned by the Excel parser to a numpy rec array. If names is None, the record names are inferred from excel_dict . Source code in oteapi_dlite/utils/nputils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dict2recarray ( excel_dict , names = None ): \"\"\"Converts a dict returned by the Excel parser to a numpy rec array. If `names` is None, the record names are inferred from `excel_dict`. \"\"\" arrays = [] for arr in excel_dict . values (): if all ( isinstance ( v , ( bool , int , float , complex , None . __class__ )) for v in arr ): arrays . append ([ np . nan if v is None else v for v in arr ]) elif all ( isinstance ( v , ( str , bytes , None . __class__ )) for v in arr ): arrays . append ([ \"\" if v is None else v for v in arr ]) else : arrays . append ( arr ) if names is None : names = list ( excel_dict . keys ()) return np . rec . fromarrays ( arrays , names = names )","title":"dict2recarray()"},{"location":"api_reference/utils/utils/","text":"utils \u00b6 Utility functions for OTEAPI DLite plugin. get_collection ( session ) \u00b6 Makes sure that the session contain a collection_id and returns the collection. Source code in oteapi_dlite/utils/utils.py 35 36 37 38 39 40 41 42 43 44 45 46 def get_collection ( session ): \"\"\"Makes sure that the session contain a `collection_id` and returns the collection.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" not in session : coll = dlite . Collection () session [ \"collection_id\" ] = coll . uuid return coll return dlite . get_instance ( session [ \"collection_id\" ]) get_driver ( mediaType = None , accessService = None , options = None ) \u00b6 Return name of DLite driver for the given media type/access service. Source code in oteapi_dlite/utils/utils.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def get_driver ( mediaType = None , accessService = None , options = None ) -> str : \"\"\"Return name of DLite driver for the given media type/access service.\"\"\" # pylint: disable=unused-argument if mediaType : if mediaType not in MEDIATYPES : raise ValueError ( \"unknown DLite mediaType: {mediaType} \" ) return MEDIATYPES [ mediaType ] if accessService : if accessService not in ACCESSSERVICES : raise ValueError ( \"unknown DLite accessService: {accessService} \" ) return ACCESSSERVICES [ accessService ] raise ValueError ( \"either `mediaType` or `accessService` must be provided\" ) get_meta ( uri ) \u00b6 Returns metadata corresponding to given uri. This function may in the future be connected to a database. Source code in oteapi_dlite/utils/utils.py 49 50 51 52 53 54 55 56 57 def get_meta ( uri : str ) -> dlite . Instance : \"\"\"Returns metadata corresponding to given uri. This function may in the future be connected to a database. \"\"\" meta = dlite . get_instance ( uri ) if not meta . is_meta : raise ValueError ( \"uri {uri} does not correspond to metadata\" ) return meta","title":"utils"},{"location":"api_reference/utils/utils/#utils","text":"Utility functions for OTEAPI DLite plugin.","title":"utils"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_collection","text":"Makes sure that the session contain a collection_id and returns the collection. Source code in oteapi_dlite/utils/utils.py 35 36 37 38 39 40 41 42 43 44 45 46 def get_collection ( session ): \"\"\"Makes sure that the session contain a `collection_id` and returns the collection.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"collection_id\" not in session : coll = dlite . Collection () session [ \"collection_id\" ] = coll . uuid return coll return dlite . get_instance ( session [ \"collection_id\" ])","title":"get_collection()"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_driver","text":"Return name of DLite driver for the given media type/access service. Source code in oteapi_dlite/utils/utils.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def get_driver ( mediaType = None , accessService = None , options = None ) -> str : \"\"\"Return name of DLite driver for the given media type/access service.\"\"\" # pylint: disable=unused-argument if mediaType : if mediaType not in MEDIATYPES : raise ValueError ( \"unknown DLite mediaType: {mediaType} \" ) return MEDIATYPES [ mediaType ] if accessService : if accessService not in ACCESSSERVICES : raise ValueError ( \"unknown DLite accessService: {accessService} \" ) return ACCESSSERVICES [ accessService ] raise ValueError ( \"either `mediaType` or `accessService` must be provided\" )","title":"get_driver()"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_meta","text":"Returns metadata corresponding to given uri. This function may in the future be connected to a database. Source code in oteapi_dlite/utils/utils.py 49 50 51 52 53 54 55 56 57 def get_meta ( uri : str ) -> dlite . Instance : \"\"\"Returns metadata corresponding to given uri. This function may in the future be connected to a database. \"\"\" meta = dlite . get_instance ( uri ) if not meta . is_meta : raise ValueError ( \"uri {uri} does not correspond to metadata\" ) return meta","title":"get_meta()"}]}