{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#oteapi-dlite-plugin","title":"OTEAPI DLite Plugin","text":"<p>All strategies implemented in this plugin (except for <code>create_collection</code>) assumes that you have the UUID of a DLite collection with the key <code>collection_id</code> in the <code>session</code>:</p> <pre><code>collection_id = session[\"collection_id\"]\ncoll = dlite.get_collection(collection_id)\n</code></pre> <p>A DLite collection stores references to DLite instances and relations between them as RDF triples. Hence, the collection is a knowledge base for the current use case.</p> <p>In order to make it easy retrieve the collection id when executing a pipeline, the <code>get()</code> method of all filters in this plugin should return the <code>collection_id</code>.</p> <p>Further reading:</p> <ul> <li>OTE-API Core Documentation</li> <li>OTE-API Services Documentation</li> <li>DLite</li> </ul>"},{"location":"#license-and-copyright","title":"License and copyright","text":"<p>The OTEAPI DLite Plugin is released under the MIT license with copyright \u00a9 SINTEF.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>OTEAPI DLite Plugin has been created via the cookiecutter template for OTE-API plugins.</p> <p>OTEAPI DLite Plugin has been supported by the following projects:</p> <ul> <li> <p>OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136.</p> </li> <li> <p>VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903.</p> </li> <li> <p>OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>This file will hold an auto-generated changelog for you project.</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"all_strategies/","title":"OTEAPI DLite Plugin Strategies","text":"<p>This page provides documentation for the <code>oteapi_dlite.strategies</code> submodule, where all the OTEAPI DLite Plugin strategies are located.</p> <p>These strategies will be available when setting up a server in an environment with oteapi-dlite installed.</p>"},{"location":"api_reference/models/session/","title":"session","text":"<p>Pydantic data models for DLite.</p>"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate","title":"<code>DLiteSessionUpdate</code>","text":"<p>         Bases: <code>SessionUpdate</code></p> <p>Class for returning values from DLite strategies.</p> Source code in <code>oteapi_dlite/models/session.py</code> <pre><code>class DLiteSessionUpdate(SessionUpdate):\n\"\"\"Class for returning values from DLite strategies.\"\"\"\n\n    collection_id: Optional[str] = Field(\n        {},  # default_factory=new_collection,\n        description=\"A reference to a DLite collection.\",\n    )\n</code></pre>"},{"location":"api_reference/models/session/#oteapi_dlite.models.session.DLiteSessionUpdate.collection_id","title":"<code>collection_id: Optional[str] = Field({}, description='A reference to a DLite collection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/","title":"filter","text":"<p>Trivial filter that adds an empty collection to the session.</p>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy","title":"<code>CreateCollectionStrategy</code>","text":"<p>Trivial filter that adds an empty collection to the session.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"dlite/create-collection\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>@dataclass\nclass CreateCollectionStrategy:\n\"\"\"Trivial filter that adds an empty collection to the session.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"dlite/create-collection\")`\n\n    \"\"\"\n\n    filter_config: FilterConfig\n\n    # Find a better way to keep collections alive!!!\n    # Need to be `Any`, because otherwise `pydantic` complains.\n    collection_refs: Dict[str, Any] = Field(\n        {},\n        description=\"A dictionary of DLite Collections.\",\n    )\n\n    def initialize(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n        if session is None:\n            raise ValueError(\"Missing session\")\n        if \"collection_id\" in session:\n            raise KeyError(\"`collection_id` already exists in session.\")\n\n        coll = dlite.Collection()\n\n        # Make sure that collection stays alive\n        # It will never be deallocated...\n        coll._incref()  # pylint: disable=protected-access\n\n        # Store the collection in the data cache\n        cache = DataCache()\n        cache.add(value=coll.asjson(), key=coll.uuid)\n\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\"\"\"\n        if session is None:\n            raise ValueError(\"Missing session\")\n        return DLiteSessionUpdate(collection_id=session[\"collection_id\"])\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\"\"\"\n    if session is None:\n        raise ValueError(\"Missing session\")\n    return DLiteSessionUpdate(collection_id=session[\"collection_id\"])\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_dlite.strategies.filter.CreateCollectionStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/filter.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n    if session is None:\n        raise ValueError(\"Missing session\")\n    if \"collection_id\" in session:\n        raise KeyError(\"`collection_id` already exists in session.\")\n\n    coll = dlite.Collection()\n\n    # Make sure that collection stays alive\n    # It will never be deallocated...\n    coll._incref()  # pylint: disable=protected-access\n\n    # Store the collection in the data cache\n    cache = DataCache()\n    cache.add(value=coll.asjson(), key=coll.uuid)\n\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/function/","title":"function","text":"<p>Generic function strategy using DLite storage plugin.</p>"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionConfig","title":"<code>DLiteFunctionConfig</code>","text":"<p>         Bases: <code>FunctionConfig</code></p> <p>DLite function strategy config.</p> Source code in <code>oteapi_dlite/strategies/function.py</code> <pre><code>class DLiteFunctionConfig(FunctionConfig):\n\"\"\"DLite function strategy config.\"\"\"\n\n    configuration: DLiteStorageConfig = Field(\n        ..., description=\"DLite function strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionStrategy","title":"<code>DLiteFunctionStrategy</code>","text":"<p>Generic DLite function strategy utilising DLite storage plugins.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.dlite-generate\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/function.py</code> <pre><code>@dataclass\nclass DLiteFunctionStrategy:\n\"\"\"Generic DLite function strategy utilising DLite storage plugins.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.dlite-generate\")`\n\n    \"\"\"\n\n    function_config: DLiteFunctionConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.function_config.configuration\n        cacheconfig = config.datacache_config\n\n        driver = (\n            config.driver\n            if config.driver\n            else get_driver(\n                mediaType=config.mediaType,\n            )\n        )\n\n        coll = get_collection(session, config.collection_id)\n        inst = coll[config.label]\n\n        # Save instance\n        if config.location:\n            inst.save(driver, config.location, config.options)\n        else:\n            if cacheconfig and cacheconfig.accessKey:\n                key = cacheconfig.accessKey\n            elif \"key\" in session:  # type: ignore\n                key = \"function_data\"\n\n            cache = DataCache()\n            with tempfile.TemporaryDirectory() as tmpdir:\n                inst.save(driver, \"{tmpdir}/data\", config.options)\n                with open(f\"{tmpdir}/data\", \"rb\") as f:\n                    cache.add(f.read(), key=key)\n\n        # __TODO__\n        # Can we savely assume that all strategies in a pipeline will be\n        # executed in the same Python interpreter?  If not, we should write\n        # the collection to a storage, such that it can be shared with the\n        # other strategies.\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/function.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.function_config.configuration\n    cacheconfig = config.datacache_config\n\n    driver = (\n        config.driver\n        if config.driver\n        else get_driver(\n            mediaType=config.mediaType,\n        )\n    )\n\n    coll = get_collection(session, config.collection_id)\n    inst = coll[config.label]\n\n    # Save instance\n    if config.location:\n        inst.save(driver, config.location, config.options)\n    else:\n        if cacheconfig and cacheconfig.accessKey:\n            key = cacheconfig.accessKey\n        elif \"key\" in session:  # type: ignore\n            key = \"function_data\"\n\n        cache = DataCache()\n        with tempfile.TemporaryDirectory() as tmpdir:\n            inst.save(driver, \"{tmpdir}/data\", config.options)\n            with open(f\"{tmpdir}/data\", \"rb\") as f:\n                cache.add(f.read(), key=key)\n\n    # __TODO__\n    # Can we savely assume that all strategies in a pipeline will be\n    # executed in the same Python interpreter?  If not, we should write\n    # the collection to a storage, such that it can be shared with the\n    # other strategies.\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteFunctionStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/function.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/function/#oteapi_dlite.strategies.function.DLiteStorageConfig","title":"<code>DLiteStorageConfig</code>","text":"<p>         Bases: <code>AttrDict</code></p> <p>Configuration for a generic DLite storage filter.</p> <p>The DLite storage driver to can be specified using either the <code>driver</code> or <code>mediaType</code> field.</p> <p>Where the output should be written, is specified using either the <code>location</code> or <code>datacache_config.accessKey</code> field.</p> Source code in <code>oteapi_dlite/strategies/function.py</code> <pre><code>class DLiteStorageConfig(AttrDict):\n\"\"\"Configuration for a generic DLite storage filter.\n\n    The DLite storage driver to can be specified using either the `driver`\n    or `mediaType` field.\n\n    Where the output should be written, is specified using either the\n    `location` or `datacache_config.accessKey` field.\n    \"\"\"\n\n    driver: Optional[str] = Field(\n        None,\n        description='Name of DLite driver (ex: \"json\").',\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description='Media type for DLite driver (ex: \"application/json\").',\n    )\n    location: Optional[str] = Field(\n        None,\n        description=(\n            \"Location of storage to write to.  If unset to store in data \"\n            \"cache using the key provided with `datacache_config.accessKey` \"\n            \"(defaults to 'function_data').\"\n        ),\n    )\n    options: Optional[str] = Field(\n        None,\n        description=(\n            \"Comma-separated list of options passed to the DLite \"\n            \"storage plugin.\"\n        ),\n    )\n    label: str = Field(\n        ...,\n        description=\"Label of DLite instance to serialise in the collection.\",\n    )\n    collection_id: Optional[str] = Field(\n        None,\n        description=(\"ID of the collection to use.\"),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/generate/","title":"generate","text":"<p>Generic generate strategy using DLite storage plugin.</p>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateConfig","title":"<code>DLiteGenerateConfig</code>","text":"<p>         Bases: <code>FunctionConfig</code></p> <p>DLite generate strategy config.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>class DLiteGenerateConfig(FunctionConfig):\n\"\"\"DLite generate strategy config.\"\"\"\n\n    configuration: DLiteStorageConfig = Field(\n        ..., description=\"DLite generate strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy","title":"<code>DLiteGenerateStrategy</code>","text":"<p>Generic DLite generate strategy utilising DLite storage plugins.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.dlite-generate\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>@dataclass\nclass DLiteGenerateStrategy:\n\"\"\"Generic DLite generate strategy utilising DLite storage plugins.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.dlite-generate\")`\n\n    \"\"\"\n\n    generate_config: DLiteGenerateConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.generate_config.configuration\n        cacheconfig = config.datacache_config\n\n        driver = (\n            config.driver\n            if config.driver\n            else get_driver(\n                mediaType=config.mediaType,\n            )\n        )\n\n        coll = get_collection(session, config.collection_id)\n\n        if config.label:\n            inst = coll[config.label]\n        elif config.datamodel:\n            instances = coll.get_instances(\n                metaid=config.datamodel,\n                property_mappings=True,\n                allow_incomplete=config.allow_incomplete,\n            )\n            inst = next(instances)\n            # fail if there are more instances\n        else:\n            raise ValueError(\n                \"One of `label` or `metadata` configurations should be given.\"\n            )\n\n        # Save instance\n        if config.location:\n            inst.save(driver, config.location, config.options)\n        else:\n            if cacheconfig and cacheconfig.accessKey:\n                key = cacheconfig.accessKey\n            elif \"key\" in session:  # type: ignore\n                key = \"generate_data\"\n\n            cache = DataCache()\n            with tempfile.TemporaryDirectory() as tmpdir:\n                inst.save(driver, \"{tmpdir}/data\", config.options)\n                with open(f\"{tmpdir}/data\", \"rb\") as f:\n                    cache.add(f.read(), key=key)\n\n        # __TODO__\n        # Can we safely assume that all strategies in a pipeline will be\n        # executed in the same Python interpreter?  If not, we should write\n        # the collection to a storage, such that it can be shared with the\n        # other strategies.\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.generate_config.configuration\n    cacheconfig = config.datacache_config\n\n    driver = (\n        config.driver\n        if config.driver\n        else get_driver(\n            mediaType=config.mediaType,\n        )\n    )\n\n    coll = get_collection(session, config.collection_id)\n\n    if config.label:\n        inst = coll[config.label]\n    elif config.datamodel:\n        instances = coll.get_instances(\n            metaid=config.datamodel,\n            property_mappings=True,\n            allow_incomplete=config.allow_incomplete,\n        )\n        inst = next(instances)\n        # fail if there are more instances\n    else:\n        raise ValueError(\n            \"One of `label` or `metadata` configurations should be given.\"\n        )\n\n    # Save instance\n    if config.location:\n        inst.save(driver, config.location, config.options)\n    else:\n        if cacheconfig and cacheconfig.accessKey:\n            key = cacheconfig.accessKey\n        elif \"key\" in session:  # type: ignore\n            key = \"generate_data\"\n\n        cache = DataCache()\n        with tempfile.TemporaryDirectory() as tmpdir:\n            inst.save(driver, \"{tmpdir}/data\", config.options)\n            with open(f\"{tmpdir}/data\", \"rb\") as f:\n                cache.add(f.read(), key=key)\n\n    # __TODO__\n    # Can we safely assume that all strategies in a pipeline will be\n    # executed in the same Python interpreter?  If not, we should write\n    # the collection to a storage, such that it can be shared with the\n    # other strategies.\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteGenerateStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/generate/#oteapi_dlite.strategies.generate.DLiteStorageConfig","title":"<code>DLiteStorageConfig</code>","text":"<p>         Bases: <code>AttrDict</code></p> <p>Configuration for a generic DLite storage filter.</p> <p>The DLite storage driver to can be specified using either the <code>driver</code> or <code>mediaType</code> field.</p> <p>Where the output should be written, is specified using either the <code>location</code> or <code>datacache_config.accessKey</code> field.</p> <p>Either <code>metadata</code> or <code>label</code> should be provided.</p> Source code in <code>oteapi_dlite/strategies/generate.py</code> <pre><code>class DLiteStorageConfig(AttrDict):\n\"\"\"Configuration for a generic DLite storage filter.\n\n    The DLite storage driver to can be specified using either the `driver`\n    or `mediaType` field.\n\n    Where the output should be written, is specified using either the\n    `location` or `datacache_config.accessKey` field.\n\n    Either `metadata` or `label` should be provided.\n    \"\"\"\n\n    label: Optional[str] = Field(\n        None,\n        description=\"Label of DLite instance in the collection to serialise.\",\n    )\n    datamodel: Optional[str] = Field(\n        None,\n        description=\"URI to metadata of new instance.  Needed when generating \"\n        \"the instance from mappings.  Cannot be combined with `label`\",\n    )\n    driver: Optional[str] = Field(\n        None,\n        description='Name of DLite driver (ex: \"json\").',\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description='Media type for DLite driver (ex: \"application/json\").',\n    )\n    location: Optional[str] = Field(\n        None,\n        description=(\n            \"Location of storage to write to.  If unset to store in data \"\n            \"cache using the key provided with `datacache_config.accessKey` \"\n            \"(defaults to 'generate_data').\"\n        ),\n    )\n    options: Optional[str] = Field(\n        None,\n        description=(\n            \"Comma-separated list of options passed to the DLite \"\n            \"storage plugin.\"\n        ),\n    )\n    allow_incomplete: Optional[bool] = Field(\n        False,\n        description=\"Whether to allow incomplete property mappings.\",\n    )\n    collection_id: Optional[str] = Field(\n        None,\n        description=(\"ID of the collection to use.\"),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/mapping/","title":"mapping","text":"<p>Mapping filter strategy.</p>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingConfig","title":"<code>DLiteMappingConfig</code>","text":"<p>         Bases: <code>MappingConfig</code></p> <p>DLite mapping strategy config.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>class DLiteMappingConfig(MappingConfig):\n\"\"\"DLite mapping strategy config.\"\"\"\n\n    configuration: DLiteMappingStrategyConfig = Field(\n        DLiteMappingStrategyConfig(),\n        description=\"DLite mapping strategy-specific configuration.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy","title":"<code>DLiteMappingStrategy</code>","text":"<p>Strategy for a mapping.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mappingType\", \"mappings\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>@dataclass\nclass DLiteMappingStrategy:\n\"\"\"Strategy for a mapping.\n\n    **Registers strategies**:\n\n    - `(\"mappingType\", \"mappings\")`\n\n    \"\"\"\n\n    mapping_config: DLiteMappingConfig\n\n    def initialize(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        coll = get_collection(session)\n        ts = Triplestore(backend=\"collection\", collection=coll)\n\n        if self.mapping_config.prefixes:\n            for prefix, iri in self.mapping_config.prefixes.items():\n                ts.bind(prefix, iri)\n\n        if self.mapping_config.triples:\n            ts.add_triples(\n                [\n                    [\n                        ts.expand_iri(t) if isinstance(t, str) else t\n                        for t in triple\n                    ]\n                    for triple in self.mapping_config.triples\n                ]\n            )\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    coll = get_collection(session)\n    ts = Triplestore(backend=\"collection\", collection=coll)\n\n    if self.mapping_config.prefixes:\n        for prefix, iri in self.mapping_config.prefixes.items():\n            ts.bind(prefix, iri)\n\n    if self.mapping_config.triples:\n        ts.add_triples(\n            [\n                [\n                    ts.expand_iri(t) if isinstance(t, str) else t\n                    for t in triple\n                ]\n                for triple in self.mapping_config.triples\n            ]\n        )\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/mapping/#oteapi_dlite.strategies.mapping.DLiteMappingStrategyConfig","title":"<code>DLiteMappingStrategyConfig</code>","text":"<p>         Bases: <code>AttrDict</code></p> <p>Configuration for a DLite mapping filter.</p> Source code in <code>oteapi_dlite/strategies/mapping.py</code> <pre><code>class DLiteMappingStrategyConfig(AttrDict):\n\"\"\"Configuration for a DLite mapping filter.\"\"\"\n\n    datamodel: Optional[AnyUrl] = Field(\n        None,\n        description=\"URI of the datamodel that is mapped.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/","title":"parse","text":"<p>Generic parse strategy using DLite storage plugin.</p>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseConfig","title":"<code>DLiteParseConfig</code>","text":"<p>         Bases: <code>AttrDict</code></p> <p>Configuration for generic DLite parser.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>class DLiteParseConfig(AttrDict):\n\"\"\"Configuration for generic DLite parser.\"\"\"\n\n    driver: Optional[str] = Field(\n        None,\n        description='Name of DLite driver (ex: \"json\").',\n    )\n    location: Optional[str] = Field(\n        None,\n        description=(\n            \"Explicit location of storage.  Normally data is read from the \"\n            \"data cache using `datacache_config.accessKey` (default: 'key').\"\n        ),\n    )\n    options: Optional[str] = Field(\n        None,\n        description=(\n            \"Comma-separated list of options passed to the DLite storage \"\n            \"plugin.\"\n        ),\n    )\n    id: Optional[str] = Field(\n        None,\n        description=\"If given, the id of the instance in the storage.\",\n    )\n    label: str = Field(\n        ...,\n        description=\"Label of the new DLite instance in the collection.\",\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseResourceConfig","title":"<code>DLiteParseResourceConfig</code>","text":"<p>         Bases: <code>ResourceConfig</code></p> <p>DLite parse strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>class DLiteParseResourceConfig(ResourceConfig):\n\"\"\"DLite parse strategy resource config.\"\"\"\n\n    configuration: DLiteParseConfig = Field(\n        ..., description=\"DLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy","title":"<code>DLiteParseStrategy</code>","text":"<p>Generic DLite parse strategy utilising DLite storage plugins.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.dlite-parse\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>@dataclass\nclass DLiteParseStrategy:\n\"\"\"Generic DLite parse strategy utilising DLite storage plugins.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.dlite-parse\")`\n\n    \"\"\"\n\n    parse_config: DLiteParseResourceConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            SessionUpdate instance.\n        \"\"\"\n        config = self.parse_config.configuration\n        cacheconfig = config.datacache_config\n\n        driver = (\n            config.driver\n            if config.driver\n            else get_driver(\n                mediaType=self.parse_config.mediaType,\n            )\n        )\n\n        # Create instance\n        if config.location:\n            inst = dlite.Instance.from_location(\n                driver=driver,\n                location=config.location,\n                options=config.options,\n                id=config.id,\n            )\n        else:\n            if cacheconfig and cacheconfig.accessKey:\n                key = cacheconfig.accessKey\n            elif session and \"key\" in session:\n                key = session[\"key\"]\n            else:\n                raise ValueError(\n                    \"either `location` or `cacheconfig.accessKey` must be \"\n                    \"provided\"\n                )\n\n            cache = DataCache()\n            with cache.getfile(key) as location:\n                inst = dlite.Instance.from_location(\n                    driver=driver,\n                    location=str(location),\n                    options=config.options,\n                    id=config.id,\n                )\n\n        # Insert inst into collection\n        coll = get_collection(session)\n        coll.add(config.label, inst)\n\n        # __TODO__\n        # See\n        # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185\n        # and following comments.\n        #\n        # Since we cannot safely assume that all strategies in a\n        # pipeline will be executed in the same Python interpreter,\n        # the collection should be written to a storage, such that it\n        # can be shared with the other strategies.\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>SessionUpdate instance.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        SessionUpdate instance.\n    \"\"\"\n    config = self.parse_config.configuration\n    cacheconfig = config.datacache_config\n\n    driver = (\n        config.driver\n        if config.driver\n        else get_driver(\n            mediaType=self.parse_config.mediaType,\n        )\n    )\n\n    # Create instance\n    if config.location:\n        inst = dlite.Instance.from_location(\n            driver=driver,\n            location=config.location,\n            options=config.options,\n            id=config.id,\n        )\n    else:\n        if cacheconfig and cacheconfig.accessKey:\n            key = cacheconfig.accessKey\n        elif session and \"key\" in session:\n            key = session[\"key\"]\n        else:\n            raise ValueError(\n                \"either `location` or `cacheconfig.accessKey` must be \"\n                \"provided\"\n            )\n\n        cache = DataCache()\n        with cache.getfile(key) as location:\n            inst = dlite.Instance.from_location(\n                driver=driver,\n                location=str(location),\n                options=config.options,\n                id=config.id,\n            )\n\n    # Insert inst into collection\n    coll = get_collection(session)\n    coll.add(config.label, inst)\n\n    # __TODO__\n    # See\n    # https://github.com/EMMC-ASBL/oteapi-dlite/pull/84#discussion_r1050437185\n    # and following comments.\n    #\n    # Since we cannot safely assume that all strategies in a\n    # pipeline will be executed in the same Python interpreter,\n    # the collection should be written to a storage, such that it\n    # can be shared with the other strategies.\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_dlite.strategies.parse.DLiteParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/","title":"parse_excel","text":"<p>Strategy for parsing an Excel spreadsheet to a DLite instance.</p>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseConfig","title":"<code>DLiteExcelParseConfig</code>","text":"<p>         Bases: <code>AttrDict</code></p> <p>Configuration for DLite Excel parser.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelParseConfig(AttrDict):\n\"\"\"Configuration for DLite Excel parser.\"\"\"\n\n    metadata: Optional[HttpUrl] = Field(\n        None,\n        description=(\n            \"URI of DLite metadata to return.  If not provided, the metadata \"\n            \"will be inferred from the excel file.\"\n        ),\n    )\n\n    id: Optional[str] = Field(None, description=\"Optional id on new instance.\")\n\n    label: Optional[str] = Field(\n        \"excel-data\",\n        description=\"Optional label for new instance in collection.\",\n    )\n\n    excel_config: XLSXParseConfig = Field(\n        ...,\n        description=\"DLite-specific excel configurations.\",\n    )\n    storage_path: Optional[str] = Field(\n        None,\n        description=\"Path to metadata storage\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelParseResourceConfig","title":"<code>DLiteExcelParseResourceConfig</code>","text":"<p>         Bases: <code>ResourceConfig</code></p> <p>DLite excel parse strategy resource config.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelParseResourceConfig(ResourceConfig):\n\"\"\"DLite excel parse strategy resource config.\"\"\"\n\n    configuration: DLiteExcelParseConfig = Field(\n        ..., description=\"DLite excel parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelSessionUpdate","title":"<code>DLiteExcelSessionUpdate</code>","text":"<p>         Bases: <code>DLiteSessionUpdate</code></p> <p>Class for returning values from DLite excel parser.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>class DLiteExcelSessionUpdate(DLiteSessionUpdate):\n\"\"\"Class for returning values from DLite excel parser.\"\"\"\n\n    inst_uuid: str = Field(\n        ...,\n        description=\"UUID of new instance.\",\n    )\n    label: str = Field(\n        ...,\n        description=\"Label of the new instance in the collection.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy","title":"<code>DLiteExcelStrategy</code>","text":"<p>Parse strategy for Excel files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\",     \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>@dataclass\nclass DLiteExcelStrategy:\n\"\"\"Parse strategy for Excel files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\",\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")`\n\n    \"\"\"\n\n    parse_config: DLiteExcelParseResourceConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint\n        of the OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            DLite instance.\n\n        \"\"\"\n        config = self.parse_config.configuration\n\n        xlsx_config = self.parse_config.dict()\n        xlsx_config[\"configuration\"] = config.excel_config\n        xlsx_config[\n            \"mediaType\"\n        ] = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n        parser: \"IParseStrategy\" = XLSXParseStrategy(xlsx_config)\n        columns = parser.get(session)[\"data\"]\n\n        names, units = zip(*[split_column_name(column) for column in columns])\n        rec = dict2recarray(columns, names=names)\n\n        if config.metadata:\n            if config.storage_path is not None:\n                for storage_path in config.storage_path.split(\"|\"):\n                    dlite.storage_path.append(storage_path)\n            meta = dlite.get_instance(config.metadata)\n            # check the metadata config would go here\n        else:\n            meta = infer_metadata(rec, units=units)\n\n        inst = meta(dimensions=[len(rec)], id=config.id)\n        for name in names:\n            inst[name] = rec[name]\n\n        # Insert inst into collection\n        coll = get_collection(session)\n        coll.add(config.label, inst)\n\n        update_collection(coll)\n        return DLiteExcelSessionUpdate(\n            collection_id=coll.uuid,\n            inst_uuid=inst.uuid,\n            label=config.label,\n        )\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>DLite instance.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint\n    of the OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        DLite instance.\n\n    \"\"\"\n    config = self.parse_config.configuration\n\n    xlsx_config = self.parse_config.dict()\n    xlsx_config[\"configuration\"] = config.excel_config\n    xlsx_config[\n        \"mediaType\"\n    ] = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    parser: \"IParseStrategy\" = XLSXParseStrategy(xlsx_config)\n    columns = parser.get(session)[\"data\"]\n\n    names, units = zip(*[split_column_name(column) for column in columns])\n    rec = dict2recarray(columns, names=names)\n\n    if config.metadata:\n        if config.storage_path is not None:\n            for storage_path in config.storage_path.split(\"|\"):\n                dlite.storage_path.append(storage_path)\n        meta = dlite.get_instance(config.metadata)\n        # check the metadata config would go here\n    else:\n        meta = infer_metadata(rec, units=units)\n\n    inst = meta(dimensions=[len(rec)], id=config.id)\n    for name in names:\n        inst[name] = rec[name]\n\n    # Insert inst into collection\n    coll = get_collection(session)\n    coll.add(config.label, inst)\n\n    update_collection(coll)\n    return DLiteExcelSessionUpdate(\n        collection_id=coll.uuid,\n        inst_uuid=inst.uuid,\n        label=config.label,\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.DLiteExcelStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.infer_metadata","title":"<code>infer_metadata(rec, units)</code>","text":"<p>Infer dlite metadata from recarray <code>rec</code>.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def infer_metadata(rec: np.recarray, units: list) -&gt; dlite.Instance:\n\"\"\"Infer dlite metadata from recarray `rec`.\"\"\"\n    rnd = getrandbits(128)\n    uri = f\"http://onto-ns.com/meta/1.0/generated_from_excel_{rnd:0x}\"\n    metadata = DataModel(\n        uri,\n        description=\"Generated datamodel from excel file.\",\n    )\n    metadata.add_dimension(\"nrows\", \"Number of rows.\")\n    for i, name in enumerate(rec.dtype.names):\n        dtype = rec[name].dtype\n        ptype = \"string\" if dtype.kind == \"U\" else dtype.name\n        metadata.add_property(name, type=ptype, dims=[\"nrows\"], unit=units[i])\n    return metadata.get()\n</code></pre>"},{"location":"api_reference/strategies/parse_excel/#oteapi_dlite.strategies.parse_excel.split_column_name","title":"<code>split_column_name(column)</code>","text":"<p>Split column name into a (name, unit) tuple.</p> Source code in <code>oteapi_dlite/strategies/parse_excel.py</code> <pre><code>def split_column_name(column):\n\"\"\"Split column name into a (name, unit) tuple.\"\"\"\n    match = re.match(r\"\\s*([^ ([&lt;]+)\\s*[([&lt;]?([^] )&gt;]*)[])&gt;]?\", column)\n    if not match:\n        return column, \"\"\n    name, unit = match.groups()\n    return name, unit\n</code></pre>"},{"location":"api_reference/strategies/parse_image/","title":"parse_image","text":"<p>Strategy class for parsing an image to a DLite instance.</p>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageConfig","title":"<code>DLiteImageConfig</code>","text":"<p>         Bases: <code>ImageParserConfig</code></p> <p>Configuration for DLite image parser.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>class DLiteImageConfig(ImageParserConfig):\n\"\"\"Configuration for DLite image parser.\"\"\"\n\n    image_label: str = Field(\n        \"image\",\n        description=\"Label to assign to the image in the collection.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy","title":"<code>DLiteImageParseStrategy</code>","text":"<p>Parse strategy for image files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"image/vnd.dlite-gif\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jpeg\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jpg\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-jp2\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-png\")</code></li> <li><code>(\"mediaType\", \"image/vnd.dlite-tiff\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>@dataclass\nclass DLiteImageParseStrategy:\n\"\"\"Parse strategy for image files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"image/vnd.dlite-gif\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jpeg\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jpg\")`\n    - `(\"mediaType\", \"image/vnd.dlite-jp2\")`\n    - `(\"mediaType\", \"image/vnd.dlite-png\")`\n    - `(\"mediaType\", \"image/vnd.dlite-tiff\")`\n\n    \"\"\"\n\n    parse_config: DLiteImageResourceConfig\n\n    def initialize(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific\n        endpoint of the OTE-API Services.  It assumes that the image to\n        parse is stored in a data cache, and can be retrieved via a key\n        that is supplied in either the session (highest priority)\n        or in the parser configuration (lowest priority).\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            DLite instance.\n        \"\"\"\n        config = self.parse_config.configuration\n\n        # Configuration for ImageDataParseStrategy in oteapi-core\n        conf = self.parse_config.dict()\n        conf[\"configuration\"] = ImageParserConfig(\n            **config.dict(),\n            extra=Extra.ignore,\n        )\n        conf[\"mediaType\"] = \"image/\" + conf[\"mediaType\"].split(\"-\")[-1]\n        core_config = ImageParserResourceConfig(**conf)\n\n        parse_strategy_session = ImageDataParseStrategy(core_config).initialize(\n            session\n        )\n        output = ImageDataParseStrategy(core_config).get(parse_strategy_session)\n\n        cache = DataCache()\n        data = cache.get(output[\"image_key\"])\n\n        meta = get_meta(\"http://onto-ns.com/meta/1.0/Image\")\n        inst = meta(dimensions=data.shape)\n        inst[\"data\"] = data\n\n        LOGGER.info(\"session: %s\", session)\n\n        coll = get_collection(session)\n        coll.add(config.image_label, inst)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.  It assumes that the image to parse is stored in a data cache, and can be retrieved via a key that is supplied in either the session (highest priority) or in the parser configuration (lowest priority).</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>DLite instance.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific\n    endpoint of the OTE-API Services.  It assumes that the image to\n    parse is stored in a data cache, and can be retrieved via a key\n    that is supplied in either the session (highest priority)\n    or in the parser configuration (lowest priority).\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        DLite instance.\n    \"\"\"\n    config = self.parse_config.configuration\n\n    # Configuration for ImageDataParseStrategy in oteapi-core\n    conf = self.parse_config.dict()\n    conf[\"configuration\"] = ImageParserConfig(\n        **config.dict(),\n        extra=Extra.ignore,\n    )\n    conf[\"mediaType\"] = \"image/\" + conf[\"mediaType\"].split(\"-\")[-1]\n    core_config = ImageParserResourceConfig(**conf)\n\n    parse_strategy_session = ImageDataParseStrategy(core_config).initialize(\n        session\n    )\n    output = ImageDataParseStrategy(core_config).get(parse_strategy_session)\n\n    cache = DataCache()\n    data = cache.get(output[\"image_key\"])\n\n    meta = get_meta(\"http://onto-ns.com/meta/1.0/Image\")\n    inst = meta(dimensions=data.shape)\n    inst[\"data\"] = data\n\n    LOGGER.info(\"session: %s\", session)\n\n    coll = get_collection(session)\n    coll.add(config.image_label, inst)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/strategies/parse_image/#oteapi_dlite.strategies.parse_image.DLiteImageResourceConfig","title":"<code>DLiteImageResourceConfig</code>","text":"<p>         Bases: <code>ResourceConfig</code></p> <p>Resource config for DLite image parser.</p> Source code in <code>oteapi_dlite/strategies/parse_image.py</code> <pre><code>class DLiteImageResourceConfig(ResourceConfig):\n\"\"\"Resource config for DLite image parser.\"\"\"\n\n    configuration: DLiteImageConfig = Field(\n        DLiteImageConfig(),\n        description=\"Image parse strategy-specific configuration.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/serialise/","title":"serialise","text":"<p>Filter for serialisation using DLite.</p>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseConfig","title":"<code>SerialiseConfig</code>","text":"<p>         Bases: <code>AttrDict</code></p> <p>DLite serialise-specific configurations.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>class SerialiseConfig(AttrDict):\n\"\"\"DLite serialise-specific configurations.\"\"\"\n\n    driver: str = Field(\n        ...,\n        description=\"Name of DLite plugin used for serialisation.\",\n    )\n    location: Path = Field(\n        ...,\n        description=\"Path or URL to serialise to.\",\n    )\n    options: Optional[str] = Field(\n        \"\",\n        description=\"Options passed to the driver.\",\n    )\n    labels: Optional[Sequence[str]] = Field(\n        None,\n        description=(\n            \"Optional sequence of labels in the collection to serialise.  \"\n            \"The default is to serialise the entire collection.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseFilterConfig","title":"<code>SerialiseFilterConfig</code>","text":"<p>         Bases: <code>FilterConfig</code></p> <p>Filter config for serialise.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>class SerialiseFilterConfig(FilterConfig):\n\"\"\"Filter config for serialise.\"\"\"\n\n    configuration: SerialiseConfig = Field(\n        ...,\n        description=\"Serialise-specific configurations.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy","title":"<code>SerialiseStrategy</code>","text":"<p>Filter for serialisation using DLite.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"dlite_serialise\")</code></li> </ul> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>@dataclass\nclass SerialiseStrategy:\n\"\"\"Filter for serialisation using DLite.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"dlite_serialise\")`\n\n    \"\"\"\n\n    filter_config: SerialiseFilterConfig\n\n    def initialize(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\"\"\"\n        config = self.filter_config.configuration\n\n        coll = get_collection(session)\n\n        storage = dlite.Storage(\n            driver_or_url=config.driver,\n            location=str(config.location),\n            options=config.options,\n        )\n        if config.labels is None:\n            coll.save_to_storage(storage)\n        else:\n            for label in config.labels:\n                inst = coll.get(label)\n                inst.save_to_storage(storage)\n\n        update_collection(coll)\n        return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Execute the strategy.\"\"\"\n    config = self.filter_config.configuration\n\n    coll = get_collection(session)\n\n    storage = dlite.Storage(\n        driver_or_url=config.driver,\n        location=str(config.location),\n        options=config.options,\n    )\n    if config.labels is None:\n        coll.save_to_storage(storage)\n    else:\n        for label in config.labels:\n            inst = coll.get(label)\n            inst.save_to_storage(storage)\n\n    update_collection(coll)\n    return DLiteSessionUpdate(collection_id=coll.uuid)\n</code></pre>"},{"location":"api_reference/strategies/serialise/#oteapi_dlite.strategies.serialise.SerialiseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi_dlite/strategies/serialise.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; DLiteSessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/utils/exceptions/","title":"exceptions","text":"<p>OTEAPI-DLite exceptions.</p>"},{"location":"api_reference/utils/exceptions/#oteapi_dlite.utils.exceptions.CollectionNotFound","title":"<code>CollectionNotFound</code>","text":"<p>         Bases: <code>OteapiDliteException</code></p> <p>A dlite.Collection could not be found.</p> Source code in <code>oteapi_dlite/utils/exceptions.py</code> <pre><code>class CollectionNotFound(OteapiDliteException):\n\"\"\"A dlite.Collection could not be found.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#oteapi_dlite.utils.exceptions.OteapiDliteException","title":"<code>OteapiDliteException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>A catch-em-all generic OTEAPI-DLite exception.</p> Source code in <code>oteapi_dlite/utils/exceptions.py</code> <pre><code>class OteapiDliteException(Exception):\n\"\"\"A catch-em-all generic OTEAPI-DLite exception.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/nputils/","title":"nputils","text":"<p>NumNy-related utility functions.</p>"},{"location":"api_reference/utils/nputils/#oteapi_dlite.utils.nputils.dict2recarray","title":"<code>dict2recarray(excel_dict, names=None)</code>","text":"<p>Converts a dict returned by the Excel parser to a numpy rec array.</p> <p>If <code>names</code> is None, the record names are inferred from <code>excel_dict</code>.</p> Source code in <code>oteapi_dlite/utils/nputils.py</code> <pre><code>def dict2recarray(excel_dict, names=None):\n\"\"\"Converts a dict returned by the Excel parser to a numpy rec array.\n\n    If `names` is None, the record names are inferred from `excel_dict`.\n    \"\"\"\n    arrays = []\n    for arr in excel_dict.values():\n        if all(\n            isinstance(v, (bool, int, float, complex, None.__class__))\n            for v in arr\n        ):\n            arrays.append([np.nan if v is None else v for v in arr])\n        elif all(isinstance(v, (str, bytes, None.__class__)) for v in arr):\n            arrays.append([\"\" if v is None else v for v in arr])\n        else:\n            arrays.append(arr)\n        if names is None:\n            names = list(excel_dict.keys())\n    return np.rec.fromarrays(arrays, names=names)\n</code></pre>"},{"location":"api_reference/utils/utils/","title":"utils","text":"<p>Utility functions for OTEAPI DLite plugin.</p>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_collection","title":"<code>get_collection(session=None, collection_id=None)</code>","text":"<p>Retrieve a DLite Collection.</p> <p>Looks for a Collection UUID in the session. If none exists, a new, empty Collection is created and stored in the session.</p> <p>If <code>collection_id</code> is provided, that id is used. If there already is a <code>collection_id</code> in the session, that is left untouched. Otherwise <code>collection_id</code> is added to the session.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>An OTEAPI session object.</p> <code>None</code> <code>collection_id</code> <code>Optional[str]</code> <p>A specific collection ID to retrieve.</p> <code>None</code> Return <p>A DLite Collection to be used throughout the OTEAPI session.</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_collection(\n    session: \"Optional[Dict[str, Any]]\" = None,\n    collection_id: \"Optional[str]\" = None,\n) -&gt; dlite.Collection:\n\"\"\"Retrieve a DLite Collection.\n\n    Looks for a Collection UUID in the session.\n    If none exists, a new, empty Collection is created and stored in the\n    session.\n\n    If `collection_id` is provided, that id is used. If there already is a\n    `collection_id` in the session, that is left untouched. Otherwise\n    `collection_id` is added to the session.\n\n    Parameters:\n        session: An OTEAPI session object.\n        collection_id: A specific collection ID to retrieve.\n\n    Return:\n        A DLite Collection to be used throughout the OTEAPI session.\n    \"\"\"\n    cache = DataCache()\n\n    session = session or {}\n    id_ = collection_id or session.get(\"collection_id\")\n\n    # Storing the collection in the datacache is not scalable.\n    # Do we really want to do that?\n    #\n    # Currently we check the datacache first and then ask dlite to look\n    # up the collection (which is the proper and scalable solution).\n    if id_ is None:\n        coll = dlite.Collection()\n        cache.add(coll.asjson(), key=coll.uuid)\n    elif id_ in cache:\n        coll = dlite.Instance.from_json(cache.get(id_), id=id_)\n    else:\n        try:\n            coll = dlite.get_instance(id_)\n        except dlite.DLiteError as exc:\n            raise CollectionNotFound(\n                f\"Could not find DLite Collection with id {id_}\"\n            ) from exc\n\n    if coll.meta.uri != dlite.COLLECTION_ENTITY:\n        raise CollectionNotFound(f\"instance with id {id_} is not a collection\")\n\n    if \"collection_id\" not in session:\n        session[\"collection_id\"] = coll.uuid\n\n    return coll\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_driver","title":"<code>get_driver(mediaType=None, accessService=None, options=None)</code>","text":"<p>Return name of DLite driver for the given media type/access service.</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_driver(mediaType=None, accessService=None, options=None) -&gt; str:\n\"\"\"Return name of DLite driver for the given media type/access service.\"\"\"\n    # pylint: disable=unused-argument\n    if mediaType:\n        if mediaType not in MEDIATYPES:\n            raise ValueError(\"unknown DLite mediaType: {mediaType}\")\n        return MEDIATYPES[mediaType]\n\n    if accessService:\n        if accessService not in ACCESSSERVICES:\n            raise ValueError(\"unknown DLite accessService: {accessService}\")\n        return ACCESSSERVICES[accessService]\n\n    raise ValueError(\"either `mediaType` or `accessService` must be provided\")\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_instance","title":"<code>get_instance(meta, collection, routedict=None, instance_id=None, allow_incomplete=False, **kwargs)</code>","text":"<p>Instantiates and returns an instance of <code>meta</code>.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>Union[str, dlite.Metadata]</code> <p>Metadata to instantiate.  Typically its URI.</p> required <code>collection</code> <code>dlite.Collection</code> <p>The collection with instances and mappings.</p> required Some less used optional arguments <p>routedict: Dict mapping property names to route number to select for     the given property.  The default is to select the route with     lowest cost. instance_id: URI of instance to create. allow_incomplete: Whether to allow not populating all properties     of the returned instance. kwargs: Additional arguments passed to dlite.mappings.instantiate().</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_instance(\n    meta: \"Union[str, dlite.Metadata]\",\n    collection: dlite.Collection,\n    routedict: \"Optional[dict]\" = None,\n    instance_id: \"Optional[str]\" = None,\n    allow_incomplete: bool = False,\n    **kwargs,\n) -&gt; dlite.Instance:\n\"\"\"Instantiates and returns an instance of `meta`.\n\n    Arguments:\n        meta: Metadata to instantiate.  Typically its URI.\n        collection: The collection with instances and mappings.\n\n    Some less used optional arguments:\n        routedict: Dict mapping property names to route number to select for\n            the given property.  The default is to select the route with\n            lowest cost.\n        instance_id: URI of instance to create.\n        allow_incomplete: Whether to allow not populating all properties\n            of the returned instance.\n        kwargs: Additional arguments passed to dlite.mappings.instantiate().\n    \"\"\"\n    ts = Triplestore(backend=\"collection\", collection=collection)\n    inst = instantiate(\n        meta=meta,\n        instances=list(collection.get_instances()),\n        triplestore=ts,\n        routedict=routedict,\n        id=instance_id,\n        allow_incomplete=allow_incomplete,\n        **kwargs,\n    )\n    return inst\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.get_meta","title":"<code>get_meta(uri)</code>","text":"<p>Returns metadata corresponding to given uri.</p> <p>This function may in the future be connected to a database.</p> Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def get_meta(uri: str) -&gt; dlite.Instance:\n\"\"\"Returns metadata corresponding to given uri.\n\n    This function may in the future be connected to a database.\n    \"\"\"\n    meta = dlite.get_instance(uri)\n    if not meta.is_meta:\n        raise ValueError(\"uri {uri} does not correspond to metadata\")\n    return meta\n</code></pre>"},{"location":"api_reference/utils/utils/#oteapi_dlite.utils.utils.update_collection","title":"<code>update_collection(collection)</code>","text":"<p>Update collection in DataCache.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>dlite.Collection</code> <p>The DLite Collection to be updated.</p> required Source code in <code>oteapi_dlite/utils/utils.py</code> <pre><code>def update_collection(collection: dlite.Collection) -&gt; None:\n\"\"\"Update collection in DataCache.\n\n    Parameters:\n        collection: The DLite Collection to be updated.\n    \"\"\"\n    cache = DataCache()\n    cache.add(value=collection.asjson(), key=collection.uuid)\n</code></pre>"}]}